/*
 * X-Road Security Server Admin API
 *
 * X-Road Security Server Admin API. Note that the error metadata responses described in some endpoints are subjects to change and may be updated in upcoming versions.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@niis.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using XRoad.Sdk.Client;
using XRoad.Sdk.Model;

namespace XRoad.Sdk.Api;

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface ISystemApiSync : IApiAccessor
{
    #region Synchronous Operations

    /// <summary>
    /// add a configured timestamping service
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator selects a new timestamping service.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to add (optional)</param>
    /// <returns>TimestampingService</returns>
    TimestampingService AddConfiguredTimestampingService(TimestampingService timestampingService = default);

    /// <summary>
    /// add a configured timestamping service
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator selects a new timestamping service.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to add (optional)</param>
    /// <returns>ApiResponse of TimestampingService</returns>
    ApiResponse<TimestampingService> AddConfiguredTimestampingServiceWithHttpInfo(
        TimestampingService timestampingService = default);

    /// <summary>
    /// delete configured timestamping service
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator removes a configured timestamping service.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to delete (optional)</param>
    /// <returns></returns>
    void DeleteConfiguredTimestampingService(TimestampingService timestampingService = default);

    /// <summary>
    /// delete configured timestamping service
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator removes a configured timestamping service.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to delete (optional)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    ApiResponse<object> DeleteConfiguredTimestampingServiceWithHttpInfo(
        TimestampingService timestampingService = default);

    /// <summary>
    /// download configuration anchor information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads the configuration anchor information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>System.IO.Stream</returns>
    Stream DownloadAnchor();

    /// <summary>
    /// download configuration anchor information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads the configuration anchor information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    ApiResponse<Stream> DownloadAnchorWithHttpInfo();

    /// <summary>
    /// download the security server certificate as gzip compressed tar archive
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads the security server TLS certificate.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>System.IO.Stream</returns>
    Stream DownloadSystemCertificate();

    /// <summary>
    /// download the security server certificate as gzip compressed tar archive
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads the security server TLS certificate.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    ApiResponse<Stream> DownloadSystemCertificateWithHttpInfo();

    /// <summary>
    /// generate new certificate request
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates a new certificate request.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="distinguishedName"> (optional)</param>
    /// <returns>System.IO.Stream</returns>
    Stream GenerateSystemCertificateRequest(DistinguishedName distinguishedName = default);

    /// <summary>
    /// generate new certificate request
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates a new certificate request.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="distinguishedName"> (optional)</param>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    ApiResponse<Stream> GenerateSystemCertificateRequestWithHttpInfo(DistinguishedName distinguishedName = default);

    /// <summary>
    /// generate a new internal TLS key and cert
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates new internal TLS key and certificate.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns></returns>
    void GenerateSystemTlsKeyAndCertificate();

    /// <summary>
    /// generate a new internal TLS key and cert
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates new internal TLS key and certificate.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of Object(void)</returns>
    ApiResponse<object> GenerateSystemTlsKeyAndCertificateWithHttpInfo();

    /// <summary>
    /// view the configuration anchor information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the configuration anchor information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>Anchor</returns>
    Anchor GetAnchor();

    /// <summary>
    /// view the configuration anchor information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the configuration anchor information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of Anchor</returns>
    ApiResponse<Anchor> GetAnchorWithHttpInfo();

    /// <summary>
    /// view the configured timestamping services
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the configured timestamping services.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>List&lt;TimestampingService&gt;</returns>
    List<TimestampingService> GetConfiguredTimestampingServices();

    /// <summary>
    /// view the configured timestamping services
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the configured timestamping services.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of List&lt;TimestampingService&gt;</returns>
    ApiResponse<List<TimestampingService>> GetConfiguredTimestampingServicesWithHttpInfo();

    /// <summary>
    /// get the node type
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the node type&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>NodeTypeResponse</returns>
    NodeTypeResponse GetNodeType();

    /// <summary>
    /// get the node type
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the node type&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of NodeTypeResponse</returns>
    ApiResponse<NodeTypeResponse> GetNodeTypeWithHttpInfo();

    /// <summary>
    /// view the security server certificate information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the security server TLS certificate information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>CertificateDetails</returns>
    CertificateDetails GetSystemCertificate();

    /// <summary>
    /// view the security server certificate information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the security server TLS certificate information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of CertificateDetails</returns>
    ApiResponse<CertificateDetails> GetSystemCertificateWithHttpInfo();

    /// <summary>
    /// import new internal TLS certificate.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator imports a new internal TLS certificate&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">certificate to add (optional)</param>
    /// <returns>CertificateDetails</returns>
    CertificateDetails ImportSystemCertificate(Stream body = default);

    /// <summary>
    /// import new internal TLS certificate.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator imports a new internal TLS certificate&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">certificate to add (optional)</param>
    /// <returns>ApiResponse of CertificateDetails</returns>
    ApiResponse<CertificateDetails> ImportSystemCertificateWithHttpInfo(Stream body = default);

    /// <summary>
    /// Read and the configuration anchor file and return the hash for a preview.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator wants to preview a configuration anchor file hash.&lt;/h3&gt; &lt;p&gt;The instance of the anchor is also validated unless the &lt;code&gt;validate_instance&lt;/code&gt; query parameter is explicitly set to false. The anchor will not be saved.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="validateInstance">Whether or not to validate the owner instance of the anchor. Set this to false explicitly when previewing an anchor in the security server initialization phase. Default value is true if the parameter is omitted. (optional, default to true)</param>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns>Anchor</returns>
    Anchor PreviewAnchor(bool? validateInstance = default, Stream body = default);

    /// <summary>
    /// Read and the configuration anchor file and return the hash for a preview.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator wants to preview a configuration anchor file hash.&lt;/h3&gt; &lt;p&gt;The instance of the anchor is also validated unless the &lt;code&gt;validate_instance&lt;/code&gt; query parameter is explicitly set to false. The anchor will not be saved.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="validateInstance">Whether or not to validate the owner instance of the anchor. Set this to false explicitly when previewing an anchor in the security server initialization phase. Default value is true if the parameter is omitted. (optional, default to true)</param>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns>ApiResponse of Anchor</returns>
    ApiResponse<Anchor> PreviewAnchorWithHttpInfo(bool? validateInstance = default, Stream body = default);

    /// <summary>
    /// Upload a configuration anchor file to replace an existing one.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator uploads a configuration anchor file anytime after the Security Server has been initialized.&lt;/h3&gt; &lt;p&gt; &lt;b&gt;Note that this only works if there already exists an anchor that can be replaced.&lt;/b&gt; When initalizing a new Security Server, use the endpoint &lt;code&gt;POST /system/anchor&lt;/code&gt; instead. &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns></returns>
    void ReplaceAnchor(Stream body = default);

    /// <summary>
    /// Upload a configuration anchor file to replace an existing one.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator uploads a configuration anchor file anytime after the Security Server has been initialized.&lt;/h3&gt; &lt;p&gt; &lt;b&gt;Note that this only works if there already exists an anchor that can be replaced.&lt;/b&gt; When initalizing a new Security Server, use the endpoint &lt;code&gt;POST /system/anchor&lt;/code&gt; instead. &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    ApiResponse<object> ReplaceAnchorWithHttpInfo(Stream body = default);

    /// <summary>
    /// get information for the system version
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the system version details.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>VersionInfo</returns>
    VersionInfo SystemVersion();

    /// <summary>
    /// get information for the system version
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the system version details.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of VersionInfo</returns>
    ApiResponse<VersionInfo> SystemVersionWithHttpInfo();

    /// <summary>
    /// Upload a new configuration anchor file when initializing a new security server.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator uploads a new configuration anchor file in the security server&#39;s initialization phase.&lt;/h3&gt; &lt;p&gt; Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that &lt;b&gt;this endpoint can only be used when initializing a new security server&lt;/b&gt;. For updating the anchor for an already initialized security server use the &lt;code&gt;PUT /system/anchor&lt;/code&gt; endpoint instead. &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns></returns>
    void UploadInitialAnchor(Stream body = default);

    /// <summary>
    /// Upload a new configuration anchor file when initializing a new security server.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator uploads a new configuration anchor file in the security server&#39;s initialization phase.&lt;/h3&gt; &lt;p&gt; Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that &lt;b&gt;this endpoint can only be used when initializing a new security server&lt;/b&gt;. For updating the anchor for an already initialized security server use the &lt;code&gt;PUT /system/anchor&lt;/code&gt; endpoint instead. &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    ApiResponse<object> UploadInitialAnchorWithHttpInfo(Stream body = default);

    #endregion Synchronous Operations
}

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface ISystemApiAsync : IApiAccessor
{
    #region Asynchronous Operations

    /// <summary>
    /// add a configured timestamping service
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator selects a new timestamping service.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to add (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of TimestampingService</returns>
    Task<TimestampingService> AddConfiguredTimestampingServiceAsync(TimestampingService timestampingService = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// add a configured timestamping service
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator selects a new timestamping service.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to add (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (TimestampingService)</returns>
    Task<ApiResponse<TimestampingService>> AddConfiguredTimestampingServiceWithHttpInfoAsync(
        TimestampingService timestampingService = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// delete configured timestamping service
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator removes a configured timestamping service.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to delete (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    Task DeleteConfiguredTimestampingServiceAsync(TimestampingService timestampingService = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// delete configured timestamping service
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator removes a configured timestamping service.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to delete (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    Task<ApiResponse<object>> DeleteConfiguredTimestampingServiceWithHttpInfoAsync(
        TimestampingService timestampingService = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// download configuration anchor information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads the configuration anchor information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    Task<Stream> DownloadAnchorAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// download configuration anchor information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads the configuration anchor information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    Task<ApiResponse<Stream>> DownloadAnchorWithHttpInfoAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// download the security server certificate as gzip compressed tar archive
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads the security server TLS certificate.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    Task<Stream> DownloadSystemCertificateAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// download the security server certificate as gzip compressed tar archive
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads the security server TLS certificate.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    Task<ApiResponse<Stream>> DownloadSystemCertificateWithHttpInfoAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// generate new certificate request
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates a new certificate request.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="distinguishedName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    Task<Stream> GenerateSystemCertificateRequestAsync(DistinguishedName distinguishedName = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// generate new certificate request
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates a new certificate request.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="distinguishedName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    Task<ApiResponse<Stream>> GenerateSystemCertificateRequestWithHttpInfoAsync(
        DistinguishedName distinguishedName = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// generate a new internal TLS key and cert
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates new internal TLS key and certificate.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    Task GenerateSystemTlsKeyAndCertificateAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// generate a new internal TLS key and cert
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates new internal TLS key and certificate.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    Task<ApiResponse<object>> GenerateSystemTlsKeyAndCertificateWithHttpInfoAsync(
        CancellationToken cancellationToken = default);

    /// <summary>
    /// view the configuration anchor information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the configuration anchor information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Anchor</returns>
    Task<Anchor> GetAnchorAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// view the configuration anchor information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the configuration anchor information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Anchor)</returns>
    Task<ApiResponse<Anchor>> GetAnchorWithHttpInfoAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// view the configured timestamping services
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the configured timestamping services.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;TimestampingService&gt;</returns>
    Task<List<TimestampingService>> GetConfiguredTimestampingServicesAsync(
        CancellationToken cancellationToken = default);

    /// <summary>
    /// view the configured timestamping services
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the configured timestamping services.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;TimestampingService&gt;)</returns>
    Task<ApiResponse<List<TimestampingService>>> GetConfiguredTimestampingServicesWithHttpInfoAsync(
        CancellationToken cancellationToken = default);

    /// <summary>
    /// get the node type
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the node type&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of NodeTypeResponse</returns>
    Task<NodeTypeResponse> GetNodeTypeAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// get the node type
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the node type&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (NodeTypeResponse)</returns>
    Task<ApiResponse<NodeTypeResponse>> GetNodeTypeWithHttpInfoAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// view the security server certificate information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the security server TLS certificate information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of CertificateDetails</returns>
    Task<CertificateDetails> GetSystemCertificateAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// view the security server certificate information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the security server TLS certificate information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (CertificateDetails)</returns>
    Task<ApiResponse<CertificateDetails>> GetSystemCertificateWithHttpInfoAsync(
        CancellationToken cancellationToken = default);

    /// <summary>
    /// import new internal TLS certificate.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator imports a new internal TLS certificate&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">certificate to add (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of CertificateDetails</returns>
    Task<CertificateDetails> ImportSystemCertificateAsync(Stream body = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// import new internal TLS certificate.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator imports a new internal TLS certificate&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">certificate to add (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (CertificateDetails)</returns>
    Task<ApiResponse<CertificateDetails>> ImportSystemCertificateWithHttpInfoAsync(Stream body = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Read and the configuration anchor file and return the hash for a preview.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator wants to preview a configuration anchor file hash.&lt;/h3&gt; &lt;p&gt;The instance of the anchor is also validated unless the &lt;code&gt;validate_instance&lt;/code&gt; query parameter is explicitly set to false. The anchor will not be saved.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="validateInstance">Whether or not to validate the owner instance of the anchor. Set this to false explicitly when previewing an anchor in the security server initialization phase. Default value is true if the parameter is omitted. (optional, default to true)</param>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Anchor</returns>
    Task<Anchor> PreviewAnchorAsync(bool? validateInstance = default, Stream body = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Read and the configuration anchor file and return the hash for a preview.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator wants to preview a configuration anchor file hash.&lt;/h3&gt; &lt;p&gt;The instance of the anchor is also validated unless the &lt;code&gt;validate_instance&lt;/code&gt; query parameter is explicitly set to false. The anchor will not be saved.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="validateInstance">Whether or not to validate the owner instance of the anchor. Set this to false explicitly when previewing an anchor in the security server initialization phase. Default value is true if the parameter is omitted. (optional, default to true)</param>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Anchor)</returns>
    Task<ApiResponse<Anchor>> PreviewAnchorWithHttpInfoAsync(bool? validateInstance = default, Stream body = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Upload a configuration anchor file to replace an existing one.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator uploads a configuration anchor file anytime after the Security Server has been initialized.&lt;/h3&gt; &lt;p&gt; &lt;b&gt;Note that this only works if there already exists an anchor that can be replaced.&lt;/b&gt; When initalizing a new Security Server, use the endpoint &lt;code&gt;POST /system/anchor&lt;/code&gt; instead. &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    Task ReplaceAnchorAsync(Stream body = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// Upload a configuration anchor file to replace an existing one.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator uploads a configuration anchor file anytime after the Security Server has been initialized.&lt;/h3&gt; &lt;p&gt; &lt;b&gt;Note that this only works if there already exists an anchor that can be replaced.&lt;/b&gt; When initalizing a new Security Server, use the endpoint &lt;code&gt;POST /system/anchor&lt;/code&gt; instead. &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    Task<ApiResponse<object>> ReplaceAnchorWithHttpInfoAsync(Stream body = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// get information for the system version
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the system version details.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of VersionInfo</returns>
    Task<VersionInfo> SystemVersionAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// get information for the system version
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the system version details.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (VersionInfo)</returns>
    Task<ApiResponse<VersionInfo>> SystemVersionWithHttpInfoAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Upload a new configuration anchor file when initializing a new security server.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator uploads a new configuration anchor file in the security server&#39;s initialization phase.&lt;/h3&gt; &lt;p&gt; Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that &lt;b&gt;this endpoint can only be used when initializing a new security server&lt;/b&gt;. For updating the anchor for an already initialized security server use the &lt;code&gt;PUT /system/anchor&lt;/code&gt; endpoint instead. &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    Task UploadInitialAnchorAsync(Stream body = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// Upload a new configuration anchor file when initializing a new security server.
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator uploads a new configuration anchor file in the security server&#39;s initialization phase.&lt;/h3&gt; &lt;p&gt; Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that &lt;b&gt;this endpoint can only be used when initializing a new security server&lt;/b&gt;. For updating the anchor for an already initialized security server use the &lt;code&gt;PUT /system/anchor&lt;/code&gt; endpoint instead. &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    Task<ApiResponse<object>> UploadInitialAnchorWithHttpInfoAsync(Stream body = default,
        CancellationToken cancellationToken = default);

    #endregion Asynchronous Operations
}

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface ISystemApi : ISystemApiSync, ISystemApiAsync
{
}

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public class SystemApi : ISystemApi
{
    private ExceptionFactory _exceptionFactory = (_, _) => null;

    /// <summary>
    /// Initializes a new instance of the <see cref="SystemApi"/> class.
    /// </summary>
    /// <returns></returns>
    public SystemApi() : this((string) null)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SystemApi"/> class.
    /// </summary>
    /// <returns></returns>
    public SystemApi(string basePath)
    {
        Configuration = Sdk.Client.Configuration.MergeConfigurations(
            GlobalConfiguration.Instance,
            new Configuration {BasePath = basePath}
        );
        Client = new ApiClient(Configuration.BasePath);
        AsynchronousClient = new ApiClient(Configuration.BasePath);
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SystemApi"/> class
    /// using Configuration object
    /// </summary>
    /// <param name="configuration">An instance of Configuration</param>
    /// <returns></returns>
    public SystemApi(Configuration configuration)
    {
        if (configuration == null) throw new ArgumentNullException("configuration");

        Configuration = Sdk.Client.Configuration.MergeConfigurations(
            GlobalConfiguration.Instance,
            configuration
        );
        Client = new ApiClient(Configuration.BasePath);
        AsynchronousClient = new ApiClient(Configuration.BasePath);
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="SystemApi"/> class
    /// using a Configuration object and client instance.
    /// </summary>
    /// <param name="client">The client interface for synchronous API access.</param>
    /// <param name="asyncClient">The client interface for asynchronous API access.</param>
    /// <param name="configuration">The configuration object.</param>
    public SystemApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
    {
        Client = client ?? throw new ArgumentNullException(nameof(client));
        AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient));
        Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// The client for accessing this underlying API asynchronously.
    /// </summary>
    public IAsynchronousClient AsynchronousClient { get; set; }

    /// <summary>
    /// The client for accessing this underlying API synchronously.
    /// </summary>
    public ISynchronousClient Client { get; set; }

    /// <summary>
    /// Gets the base path of the API client.
    /// </summary>
    /// <value>The base path</value>
    public string GetBasePath()
    {
        return Configuration.BasePath;
    }

    /// <summary>
    /// Gets or sets the configuration object
    /// </summary>
    /// <value>An instance of the Configuration</value>
    public IReadableConfiguration Configuration { get; set; }

    /// <summary>
    /// Provides a factory method hook for the creation of exceptions.
    /// </summary>
    public ExceptionFactory ExceptionFactory
    {
        get
        {
            if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
            return _exceptionFactory;
        }
        set => _exceptionFactory = value;
    }

    /// <summary>
    /// add a configured timestamping service &lt;h3&gt;Administrator selects a new timestamping service.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to add (optional)</param>
    /// <returns>TimestampingService</returns>
    public TimestampingService AddConfiguredTimestampingService(TimestampingService timestampingService = default)
    {
        var localVarResponse = AddConfiguredTimestampingServiceWithHttpInfo(timestampingService);
        return localVarResponse.Data;
    }

    /// <summary>
    /// add a configured timestamping service &lt;h3&gt;Administrator selects a new timestamping service.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to add (optional)</param>
    /// <returns>ApiResponse of TimestampingService</returns>
    public ApiResponse<TimestampingService> AddConfiguredTimestampingServiceWithHttpInfo(
        TimestampingService timestampingService = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = timestampingService;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse =
            Client.Post<TimestampingService>("/system/timestamping-services", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("AddConfiguredTimestampingService", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// add a configured timestamping service &lt;h3&gt;Administrator selects a new timestamping service.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to add (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of TimestampingService</returns>
    public async Task<TimestampingService> AddConfiguredTimestampingServiceAsync(
        TimestampingService timestampingService = default, CancellationToken cancellationToken = default)
    {
        var localVarResponse =
            await AddConfiguredTimestampingServiceWithHttpInfoAsync(timestampingService, cancellationToken)
                .ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// add a configured timestamping service &lt;h3&gt;Administrator selects a new timestamping service.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to add (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (TimestampingService)</returns>
    public async Task<ApiResponse<TimestampingService>> AddConfiguredTimestampingServiceWithHttpInfoAsync(
        TimestampingService timestampingService = default, CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = timestampingService;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient.PostAsync<TimestampingService>("/system/timestamping-services",
            localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("AddConfiguredTimestampingService", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// delete configured timestamping service &lt;h3&gt;Administrator removes a configured timestamping service.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to delete (optional)</param>
    /// <returns></returns>
    public void DeleteConfiguredTimestampingService(TimestampingService timestampingService = default)
    {
        DeleteConfiguredTimestampingServiceWithHttpInfo(timestampingService);
    }

    /// <summary>
    /// delete configured timestamping service &lt;h3&gt;Administrator removes a configured timestamping service.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to delete (optional)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    public ApiResponse<object> DeleteConfiguredTimestampingServiceWithHttpInfo(
        TimestampingService timestampingService = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(Array.Empty<string>());
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = timestampingService;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse =
            Client.Post<object>("/system/timestamping-services/delete", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("DeleteConfiguredTimestampingService", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// delete configured timestamping service &lt;h3&gt;Administrator removes a configured timestamping service.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to delete (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    public async Task DeleteConfiguredTimestampingServiceAsync(TimestampingService timestampingService = default,
        CancellationToken cancellationToken = default)
    {
        await DeleteConfiguredTimestampingServiceWithHttpInfoAsync(timestampingService, cancellationToken)
            .ConfigureAwait(false);
    }

    /// <summary>
    /// delete configured timestamping service &lt;h3&gt;Administrator removes a configured timestamping service.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="timestampingService">Timestamping service to delete (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    public async Task<ApiResponse<object>> DeleteConfiguredTimestampingServiceWithHttpInfoAsync(
        TimestampingService timestampingService = default, CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(Array.Empty<string>());
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = timestampingService;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient.PostAsync<object>("/system/timestamping-services/delete",
            localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("DeleteConfiguredTimestampingService", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// download configuration anchor information &lt;h3&gt;Administrator downloads the configuration anchor information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>System.IO.Stream</returns>
    public Stream DownloadAnchor()
    {
        var localVarResponse = DownloadAnchorWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    /// download configuration anchor information &lt;h3&gt;Administrator downloads the configuration anchor information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    public ApiResponse<Stream> DownloadAnchorWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/xml"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = Client.Get<Stream>("/system/anchor/download", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("DownloadAnchor", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// download configuration anchor information &lt;h3&gt;Administrator downloads the configuration anchor information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    public async Task<Stream> DownloadAnchorAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse = await DownloadAnchorWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// download configuration anchor information &lt;h3&gt;Administrator downloads the configuration anchor information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    public async Task<ApiResponse<Stream>> DownloadAnchorWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/xml"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<Stream>("/system/anchor/download", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("DownloadAnchor", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// download the security server certificate as gzip compressed tar archive &lt;h3&gt;Administrator downloads the security server TLS certificate.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>System.IO.Stream</returns>
    public Stream DownloadSystemCertificate()
    {
        var localVarResponse = DownloadSystemCertificateWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    /// download the security server certificate as gzip compressed tar archive &lt;h3&gt;Administrator downloads the security server TLS certificate.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    public ApiResponse<Stream> DownloadSystemCertificateWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/gzip"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = Client.Get<Stream>("/system/certificate/export", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("DownloadSystemCertificate", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// download the security server certificate as gzip compressed tar archive &lt;h3&gt;Administrator downloads the security server TLS certificate.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    public async Task<Stream> DownloadSystemCertificateAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse =
            await DownloadSystemCertificateWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// download the security server certificate as gzip compressed tar archive &lt;h3&gt;Administrator downloads the security server TLS certificate.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    public async Task<ApiResponse<Stream>> DownloadSystemCertificateWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/gzip"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<Stream>("/system/certificate/export", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("DownloadSystemCertificate", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// generate new certificate request &lt;h3&gt;Administrator generates a new certificate request.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="distinguishedName"> (optional)</param>
    /// <returns>System.IO.Stream</returns>
    public Stream GenerateSystemCertificateRequest(DistinguishedName distinguishedName = default)
    {
        var localVarResponse = GenerateSystemCertificateRequestWithHttpInfo(distinguishedName);
        return localVarResponse.Data;
    }

    /// <summary>
    /// generate new certificate request &lt;h3&gt;Administrator generates a new certificate request.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="distinguishedName"> (optional)</param>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    public ApiResponse<Stream> GenerateSystemCertificateRequestWithHttpInfo(
        DistinguishedName distinguishedName = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/octet-stream"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = distinguishedName;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = Client.Post<Stream>("/system/certificate/csr", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GenerateSystemCertificateRequest", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// generate new certificate request &lt;h3&gt;Administrator generates a new certificate request.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="distinguishedName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    public async Task<Stream> GenerateSystemCertificateRequestAsync(DistinguishedName distinguishedName = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse =
            await GenerateSystemCertificateRequestWithHttpInfoAsync(distinguishedName, cancellationToken)
                .ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// generate new certificate request &lt;h3&gt;Administrator generates a new certificate request.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="distinguishedName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    public async Task<ApiResponse<Stream>> GenerateSystemCertificateRequestWithHttpInfoAsync(
        DistinguishedName distinguishedName = default, CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/octet-stream"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = distinguishedName;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<Stream>("/system/certificate/csr", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("GenerateSystemCertificateRequest", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// generate a new internal TLS key and cert &lt;h3&gt;Administrator generates new internal TLS key and certificate.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns></returns>
    public void GenerateSystemTlsKeyAndCertificate()
    {
        GenerateSystemTlsKeyAndCertificateWithHttpInfo();
    }

    /// <summary>
    /// generate a new internal TLS key and cert &lt;h3&gt;Administrator generates new internal TLS key and certificate.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of Object(void)</returns>
    public ApiResponse<object> GenerateSystemTlsKeyAndCertificateWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = Client.Post<object>("/system/certificate", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GenerateSystemTlsKeyAndCertificate", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// generate a new internal TLS key and cert &lt;h3&gt;Administrator generates new internal TLS key and certificate.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    public async Task GenerateSystemTlsKeyAndCertificateAsync(CancellationToken cancellationToken = default)
    {
        await GenerateSystemTlsKeyAndCertificateWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// generate a new internal TLS key and cert &lt;h3&gt;Administrator generates new internal TLS key and certificate.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    public async Task<ApiResponse<object>> GenerateSystemTlsKeyAndCertificateWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<object>("/system/certificate", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("GenerateSystemTlsKeyAndCertificate", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// view the configuration anchor information &lt;h3&gt;Administrator views the configuration anchor information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>Anchor</returns>
    public Anchor GetAnchor()
    {
        var localVarResponse = GetAnchorWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    /// view the configuration anchor information &lt;h3&gt;Administrator views the configuration anchor information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of Anchor</returns>
    public ApiResponse<Anchor> GetAnchorWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = Client.Get<Anchor>("/system/anchor", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GetAnchor", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// view the configuration anchor information &lt;h3&gt;Administrator views the configuration anchor information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Anchor</returns>
    public async Task<Anchor> GetAnchorAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse = await GetAnchorWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// view the configuration anchor information &lt;h3&gt;Administrator views the configuration anchor information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Anchor)</returns>
    public async Task<ApiResponse<Anchor>> GetAnchorWithHttpInfoAsync(CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<Anchor>("/system/anchor", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("GetAnchor", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// view the configured timestamping services &lt;h3&gt;Administrator views the configured timestamping services.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>List&lt;TimestampingService&gt;</returns>
    public List<TimestampingService> GetConfiguredTimestampingServices()
    {
        var localVarResponse = GetConfiguredTimestampingServicesWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    /// view the configured timestamping services &lt;h3&gt;Administrator views the configured timestamping services.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of List&lt;TimestampingService&gt;</returns>
    public ApiResponse<List<TimestampingService>> GetConfiguredTimestampingServicesWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse =
            Client.Get<List<TimestampingService>>("/system/timestamping-services", localVarRequestOptions,
                Configuration);
        if (ExceptionFactory?.Invoke("GetConfiguredTimestampingServices", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// view the configured timestamping services &lt;h3&gt;Administrator views the configured timestamping services.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;TimestampingService&gt;</returns>
    public async Task<List<TimestampingService>> GetConfiguredTimestampingServicesAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarResponse = await GetConfiguredTimestampingServicesWithHttpInfoAsync(cancellationToken)
            .ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// view the configured timestamping services &lt;h3&gt;Administrator views the configured timestamping services.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;TimestampingService&gt;)</returns>
    public async Task<ApiResponse<List<TimestampingService>>> GetConfiguredTimestampingServicesWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<List<TimestampingService>>("/system/timestamping-services", localVarRequestOptions, Configuration,
                cancellationToken).ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("GetConfiguredTimestampingServices", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// get the node type &lt;h3&gt;Administrator views the node type&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>NodeTypeResponse</returns>
    public NodeTypeResponse GetNodeType()
    {
        var localVarResponse = GetNodeTypeWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    /// get the node type &lt;h3&gt;Administrator views the node type&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of NodeTypeResponse</returns>
    public ApiResponse<NodeTypeResponse> GetNodeTypeWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = Client.Get<NodeTypeResponse>("/system/node-type", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GetNodeType", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// get the node type &lt;h3&gt;Administrator views the node type&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of NodeTypeResponse</returns>
    public async Task<NodeTypeResponse> GetNodeTypeAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse = await GetNodeTypeWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get the node type &lt;h3&gt;Administrator views the node type&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (NodeTypeResponse)</returns>
    public async Task<ApiResponse<NodeTypeResponse>> GetNodeTypeWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<NodeTypeResponse>("/system/node-type", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("GetNodeType", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// view the security server certificate information &lt;h3&gt;Administrator views the security server TLS certificate information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>CertificateDetails</returns>
    public CertificateDetails GetSystemCertificate()
    {
        var localVarResponse = GetSystemCertificateWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    /// view the security server certificate information &lt;h3&gt;Administrator views the security server TLS certificate information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of CertificateDetails</returns>
    public ApiResponse<CertificateDetails> GetSystemCertificateWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse =
            Client.Get<CertificateDetails>("/system/certificate", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GetSystemCertificate", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// view the security server certificate information &lt;h3&gt;Administrator views the security server TLS certificate information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of CertificateDetails</returns>
    public async Task<CertificateDetails> GetSystemCertificateAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse = await GetSystemCertificateWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// view the security server certificate information &lt;h3&gt;Administrator views the security server TLS certificate information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (CertificateDetails)</returns>
    public async Task<ApiResponse<CertificateDetails>> GetSystemCertificateWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<CertificateDetails>("/system/certificate", localVarRequestOptions, Configuration,
                cancellationToken).ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("GetSystemCertificate", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// import new internal TLS certificate. &lt;h3&gt;Administrator imports a new internal TLS certificate&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">certificate to add (optional)</param>
    /// <returns>CertificateDetails</returns>
    public CertificateDetails ImportSystemCertificate(Stream body = default)
    {
        var localVarResponse = ImportSystemCertificateWithHttpInfo(body);
        return localVarResponse.Data;
    }

    /// <summary>
    /// import new internal TLS certificate. &lt;h3&gt;Administrator imports a new internal TLS certificate&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">certificate to add (optional)</param>
    /// <returns>ApiResponse of CertificateDetails</returns>
    public ApiResponse<CertificateDetails> ImportSystemCertificateWithHttpInfo(Stream body = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/octet-stream"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = body;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse =
            Client.Post<CertificateDetails>("/system/certificate/import", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("ImportSystemCertificate", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// import new internal TLS certificate. &lt;h3&gt;Administrator imports a new internal TLS certificate&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">certificate to add (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of CertificateDetails</returns>
    public async Task<CertificateDetails> ImportSystemCertificateAsync(Stream body = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse =
            await ImportSystemCertificateWithHttpInfoAsync(body, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// import new internal TLS certificate. &lt;h3&gt;Administrator imports a new internal TLS certificate&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">certificate to add (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (CertificateDetails)</returns>
    public async Task<ApiResponse<CertificateDetails>> ImportSystemCertificateWithHttpInfoAsync(Stream body = default,
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/octet-stream"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = body;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<CertificateDetails>("/system/certificate/import", localVarRequestOptions, Configuration,
                cancellationToken).ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("ImportSystemCertificate", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// Read and the configuration anchor file and return the hash for a preview. &lt;h3&gt;Administrator wants to preview a configuration anchor file hash.&lt;/h3&gt; &lt;p&gt;The instance of the anchor is also validated unless the &lt;code&gt;validate_instance&lt;/code&gt; query parameter is explicitly set to false. The anchor will not be saved.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="validateInstance">Whether or not to validate the owner instance of the anchor. Set this to false explicitly when previewing an anchor in the security server initialization phase. Default value is true if the parameter is omitted. (optional, default to true)</param>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns>Anchor</returns>
    public Anchor PreviewAnchor(bool? validateInstance = default, Stream body = default)
    {
        var localVarResponse = PreviewAnchorWithHttpInfo(validateInstance, body);
        return localVarResponse.Data;
    }

    /// <summary>
    /// Read and the configuration anchor file and return the hash for a preview. &lt;h3&gt;Administrator wants to preview a configuration anchor file hash.&lt;/h3&gt; &lt;p&gt;The instance of the anchor is also validated unless the &lt;code&gt;validate_instance&lt;/code&gt; query parameter is explicitly set to false. The anchor will not be saved.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="validateInstance">Whether or not to validate the owner instance of the anchor. Set this to false explicitly when previewing an anchor in the security server initialization phase. Default value is true if the parameter is omitted. (optional, default to true)</param>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns>ApiResponse of Anchor</returns>
    public ApiResponse<Anchor> PreviewAnchorWithHttpInfo(bool? validateInstance = default, Stream body = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/octet-stream"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        if (validateInstance != null)
            localVarRequestOptions.QueryParameters.Add(
                ClientUtils.ParameterToMultiMap("", "validate_instance", validateInstance));
        localVarRequestOptions.Data = body;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Post<Anchor>("/system/anchor/previews", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("PreviewAnchor", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// Read and the configuration anchor file and return the hash for a preview. &lt;h3&gt;Administrator wants to preview a configuration anchor file hash.&lt;/h3&gt; &lt;p&gt;The instance of the anchor is also validated unless the &lt;code&gt;validate_instance&lt;/code&gt; query parameter is explicitly set to false. The anchor will not be saved.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="validateInstance">Whether or not to validate the owner instance of the anchor. Set this to false explicitly when previewing an anchor in the security server initialization phase. Default value is true if the parameter is omitted. (optional, default to true)</param>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Anchor</returns>
    public async Task<Anchor> PreviewAnchorAsync(bool? validateInstance = default, Stream body = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse = await PreviewAnchorWithHttpInfoAsync(validateInstance, body, cancellationToken)
            .ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// Read and the configuration anchor file and return the hash for a preview. &lt;h3&gt;Administrator wants to preview a configuration anchor file hash.&lt;/h3&gt; &lt;p&gt;The instance of the anchor is also validated unless the &lt;code&gt;validate_instance&lt;/code&gt; query parameter is explicitly set to false. The anchor will not be saved.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="validateInstance">Whether or not to validate the owner instance of the anchor. Set this to false explicitly when previewing an anchor in the security server initialization phase. Default value is true if the parameter is omitted. (optional, default to true)</param>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Anchor)</returns>
    public async Task<ApiResponse<Anchor>> PreviewAnchorWithHttpInfoAsync(bool? validateInstance = default,
        Stream body = default, CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/octet-stream"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        if (validateInstance != null)
            localVarRequestOptions.QueryParameters.Add(
                ClientUtils.ParameterToMultiMap("", "validate_instance", validateInstance));
        localVarRequestOptions.Data = body;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<Anchor>("/system/anchor/previews", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("PreviewAnchor", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// Upload a configuration anchor file to replace an existing one. &lt;h3&gt;Administrator uploads a configuration anchor file anytime after the Security Server has been initialized.&lt;/h3&gt; &lt;p&gt; &lt;b&gt;Note that this only works if there already exists an anchor that can be replaced.&lt;/b&gt; When initalizing a new Security Server, use the endpoint &lt;code&gt;POST /system/anchor&lt;/code&gt; instead. &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns></returns>
    public void ReplaceAnchor(Stream body = default)
    {
        ReplaceAnchorWithHttpInfo(body);
    }

    /// <summary>
    /// Upload a configuration anchor file to replace an existing one. &lt;h3&gt;Administrator uploads a configuration anchor file anytime after the Security Server has been initialized.&lt;/h3&gt; &lt;p&gt; &lt;b&gt;Note that this only works if there already exists an anchor that can be replaced.&lt;/b&gt; When initalizing a new Security Server, use the endpoint &lt;code&gt;POST /system/anchor&lt;/code&gt; instead. &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    public ApiResponse<object> ReplaceAnchorWithHttpInfo(Stream body = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/octet-stream"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(Array.Empty<string>());
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = body;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = Client.Put<object>("/system/anchor", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("ReplaceAnchor", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// Upload a configuration anchor file to replace an existing one. &lt;h3&gt;Administrator uploads a configuration anchor file anytime after the Security Server has been initialized.&lt;/h3&gt; &lt;p&gt; &lt;b&gt;Note that this only works if there already exists an anchor that can be replaced.&lt;/b&gt; When initalizing a new Security Server, use the endpoint &lt;code&gt;POST /system/anchor&lt;/code&gt; instead. &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    public async Task ReplaceAnchorAsync(Stream body = default, CancellationToken cancellationToken = default)
    {
        await ReplaceAnchorWithHttpInfoAsync(body, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Upload a configuration anchor file to replace an existing one. &lt;h3&gt;Administrator uploads a configuration anchor file anytime after the Security Server has been initialized.&lt;/h3&gt; &lt;p&gt; &lt;b&gt;Note that this only works if there already exists an anchor that can be replaced.&lt;/b&gt; When initalizing a new Security Server, use the endpoint &lt;code&gt;POST /system/anchor&lt;/code&gt; instead. &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    public async Task<ApiResponse<object>> ReplaceAnchorWithHttpInfoAsync(Stream body = default,
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(Array.Empty<string>());
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = body;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PutAsync<object>("/system/anchor", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("ReplaceAnchor", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// get information for the system version &lt;h3&gt;Administrator views the system version details.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>VersionInfo</returns>
    public VersionInfo SystemVersion()
    {
        var localVarResponse = SystemVersionWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    /// get information for the system version &lt;h3&gt;Administrator views the system version details.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of VersionInfo</returns>
    public ApiResponse<VersionInfo> SystemVersionWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = Client.Get<VersionInfo>("/system/version", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("SystemVersion", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// get information for the system version &lt;h3&gt;Administrator views the system version details.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of VersionInfo</returns>
    public async Task<VersionInfo> SystemVersionAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse = await SystemVersionWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get information for the system version &lt;h3&gt;Administrator views the system version details.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (VersionInfo)</returns>
    public async Task<ApiResponse<VersionInfo>> SystemVersionWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/octet-stream"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<VersionInfo>("/system/version", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("SystemVersion", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// Upload a new configuration anchor file when initializing a new security server. &lt;h3&gt;Administrator uploads a new configuration anchor file in the security server&#39;s initialization phase.&lt;/h3&gt; &lt;p&gt; Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that &lt;b&gt;this endpoint can only be used when initializing a new security server&lt;/b&gt;. For updating the anchor for an already initialized security server use the &lt;code&gt;PUT /system/anchor&lt;/code&gt; endpoint instead. &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns></returns>
    public void UploadInitialAnchor(Stream body = default)
    {
        UploadInitialAnchorWithHttpInfo(body);
    }

    /// <summary>
    /// Upload a new configuration anchor file when initializing a new security server. &lt;h3&gt;Administrator uploads a new configuration anchor file in the security server&#39;s initialization phase.&lt;/h3&gt; &lt;p&gt; Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that &lt;b&gt;this endpoint can only be used when initializing a new security server&lt;/b&gt;. For updating the anchor for an already initialized security server use the &lt;code&gt;PUT /system/anchor&lt;/code&gt; endpoint instead. &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    public ApiResponse<object> UploadInitialAnchorWithHttpInfo(Stream body = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(Array.Empty<string>());
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = body;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = Client.Post<object>("/system/anchor", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("UploadInitialAnchor", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }

    /// <summary>
    /// Upload a new configuration anchor file when initializing a new security server. &lt;h3&gt;Administrator uploads a new configuration anchor file in the security server&#39;s initialization phase.&lt;/h3&gt; &lt;p&gt; Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that &lt;b&gt;this endpoint can only be used when initializing a new security server&lt;/b&gt;. For updating the anchor for an already initialized security server use the &lt;code&gt;PUT /system/anchor&lt;/code&gt; endpoint instead. &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    public async Task UploadInitialAnchorAsync(Stream body = default, CancellationToken cancellationToken = default)
    {
        await UploadInitialAnchorWithHttpInfoAsync(body, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// Upload a new configuration anchor file when initializing a new security server. &lt;h3&gt;Administrator uploads a new configuration anchor file in the security server&#39;s initialization phase.&lt;/h3&gt; &lt;p&gt; Calls to this endpoint only succeed if a configuration anchor is not already found – meaning that &lt;b&gt;this endpoint can only be used when initializing a new security server&lt;/b&gt;. For updating the anchor for an already initialized security server use the &lt;code&gt;PUT /system/anchor&lt;/code&gt; endpoint instead. &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="body">configuration anchor (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    public async Task<ApiResponse<object>> UploadInitialAnchorWithHttpInfoAsync(Stream body = default,
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
        var localVarAccept = ClientUtils.SelectHeaderAccept(Array.Empty<string>());
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
        localVarRequestOptions.Data = body;
        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));
        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<object>("/system/anchor", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);
        if (ExceptionFactory?.Invoke("UploadInitialAnchor", localVarResponse) is { } exception) throw exception;
        return localVarResponse;
    }
}