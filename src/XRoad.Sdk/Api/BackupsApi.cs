/*
 * X-Road Security Server Admin API
 *
 * X-Road Security Server Admin API. Note that the error metadata responses described in some endpoints are subjects to change and may be updated in upcoming versions.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@niis.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using XRoad.Sdk.Client;
using XRoad.Sdk.Model;

namespace XRoad.Sdk.Api;

/// <summary>
///     Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface IBackupsApiSync : IApiAccessor
{
    #region Synchronous Operations

    /// <summary>
    ///     add new backup for the security server
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in
    ///     the error response. The metadata array contains the output of a failed backup generation script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>Backup</returns>
    Backup AddBackup();

    /// <summary>
    ///     add new backup for the security server
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in
    ///     the error response. The metadata array contains the output of a failed backup generation script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of Backup</returns>
    ApiResponse<Backup> AddBackupWithHttpInfo();

    /// <summary>
    ///     add new backup for the security server and return extra backup state
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in
    ///     the error response. The metadata array contains the output of a failed backup generation script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>BackupExt</returns>
    BackupExt AddBackupExt();

    /// <summary>
    ///     add new backup for the security server and return extra backup state
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in
    ///     the error response. The metadata array contains the output of a failed backup generation script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of BackupExt</returns>
    ApiResponse<BackupExt> AddBackupExtWithHttpInfo();

    /// <summary>
    ///     delete security server backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator deletes the backup of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns></returns>
    void DeleteBackup(string filename);

    /// <summary>
    ///     delete security server backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator deletes the backup of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>ApiResponse of Object(void)</returns>
    ApiResponse<object> DeleteBackupWithHttpInfo(string filename);

    /// <summary>
    ///     download security server backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator downloads the backup of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>System.IO.Stream</returns>
    Stream DownloadBackup(string filename);

    /// <summary>
    ///     download security server backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator downloads the backup of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    ApiResponse<Stream> DownloadBackupWithHttpInfo(string filename);

    /// <summary>
    ///     get security server backups
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator views the backups for the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>List&lt;Backup&gt;</returns>
    List<Backup> GetBackups();

    /// <summary>
    ///     get security server backups
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator views the backups for the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of List&lt;Backup&gt;</returns>
    ApiResponse<List<Backup>> GetBackupsWithHttpInfo();

    /// <summary>
    ///     restore security server configuration from backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator restores the security server configuration from backup.&lt;/h3&gt; &lt;p&gt;This endpoint
    ///     can also return metadata in the error response. The metadata array contains the output of a failed backup restore
    ///     script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>TokensLoggedOut</returns>
    TokensLoggedOut RestoreBackup(string filename);

    /// <summary>
    ///     restore security server configuration from backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator restores the security server configuration from backup.&lt;/h3&gt; &lt;p&gt;This endpoint
    ///     can also return metadata in the error response. The metadata array contains the output of a failed backup restore
    ///     script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>ApiResponse of TokensLoggedOut</returns>
    ApiResponse<TokensLoggedOut> RestoreBackupWithHttpInfo(string filename);

    /// <summary>
    ///     upload new backup for the security server
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Uploads new security server backup to the system.&lt;/h3&gt; &lt;p&gt;Note that it is possible to
    ///     overwrite an existing backup file with the same name. &lt;ul&gt; &lt;li&gt;Attempt to upload a new backup file
    ///     having the same name with an existing backup and with query parameter &lt;code&gt;ignore_warnings&lt;/code&gt;
    ///     &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;
    ///     Attempt to upload a new backup file having the same name with an existing backup and with query parameter &lt;code
    ///     &gt;ignore_warnings&lt;/code&gt; &#x3D; true will overwrite the existing backup.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    ///     &lt;p&gt;The warning response has a warning code &lt;code&gt;warning_file_already_exists&lt;/code&gt; and the
    ///     metadata field contains the name of the existing backup&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="ignoreWarnings">
    ///     If true, any ignorable warnings are ignored. if false (or missing), any warnings cause
    ///     request to fail. (optional, default to false)
    /// </param>
    /// <param name="file"> (optional)</param>
    /// <returns>Backup</returns>
    Backup UploadBackup(bool? ignoreWarnings = default, Stream file = default);

    /// <summary>
    ///     upload new backup for the security server
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Uploads new security server backup to the system.&lt;/h3&gt; &lt;p&gt;Note that it is possible to
    ///     overwrite an existing backup file with the same name. &lt;ul&gt; &lt;li&gt;Attempt to upload a new backup file
    ///     having the same name with an existing backup and with query parameter &lt;code&gt;ignore_warnings&lt;/code&gt;
    ///     &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;
    ///     Attempt to upload a new backup file having the same name with an existing backup and with query parameter &lt;code
    ///     &gt;ignore_warnings&lt;/code&gt; &#x3D; true will overwrite the existing backup.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    ///     &lt;p&gt;The warning response has a warning code &lt;code&gt;warning_file_already_exists&lt;/code&gt; and the
    ///     metadata field contains the name of the existing backup&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="ignoreWarnings">
    ///     If true, any ignorable warnings are ignored. if false (or missing), any warnings cause
    ///     request to fail. (optional, default to false)
    /// </param>
    /// <param name="file"> (optional)</param>
    /// <returns>ApiResponse of Backup</returns>
    ApiResponse<Backup> UploadBackupWithHttpInfo(bool? ignoreWarnings = default, Stream file = default);

    #endregion Synchronous Operations
}

/// <summary>
///     Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface IBackupsApiAsync : IApiAccessor
{
    #region Asynchronous Operations

    /// <summary>
    ///     add new backup for the security server
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in
    ///     the error response. The metadata array contains the output of a failed backup generation script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Backup</returns>
    Task<Backup> AddBackupAsync(CancellationToken cancellationToken = default);

    /// <summary>
    ///     add new backup for the security server
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in
    ///     the error response. The metadata array contains the output of a failed backup generation script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Backup)</returns>
    Task<ApiResponse<Backup>> AddBackupWithHttpInfoAsync(CancellationToken cancellationToken = default);

    /// <summary>
    ///     add new backup for the security server and return extra backup state
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in
    ///     the error response. The metadata array contains the output of a failed backup generation script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of BackupExt</returns>
    Task<BackupExt> AddBackupExtAsync(CancellationToken cancellationToken = default);

    /// <summary>
    ///     add new backup for the security server and return extra backup state
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in
    ///     the error response. The metadata array contains the output of a failed backup generation script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (BackupExt)</returns>
    Task<ApiResponse<BackupExt>> AddBackupExtWithHttpInfoAsync(CancellationToken cancellationToken = default);

    /// <summary>
    ///     delete security server backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator deletes the backup of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    Task DeleteBackupAsync(string filename, CancellationToken cancellationToken = default);

    /// <summary>
    ///     delete security server backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator deletes the backup of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    Task<ApiResponse<object>> DeleteBackupWithHttpInfoAsync(string filename,
        CancellationToken cancellationToken = default);

    /// <summary>
    ///     download security server backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator downloads the backup of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    Task<Stream> DownloadBackupAsync(string filename, CancellationToken cancellationToken = default);

    /// <summary>
    ///     download security server backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator downloads the backup of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    Task<ApiResponse<Stream>> DownloadBackupWithHttpInfoAsync(string filename,
        CancellationToken cancellationToken = default);

    /// <summary>
    ///     get security server backups
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator views the backups for the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;Backup&gt;</returns>
    Task<List<Backup>> GetBackupsAsync(CancellationToken cancellationToken = default);

    /// <summary>
    ///     get security server backups
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator views the backups for the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;Backup&gt;)</returns>
    Task<ApiResponse<List<Backup>>> GetBackupsWithHttpInfoAsync(CancellationToken cancellationToken = default);

    /// <summary>
    ///     restore security server configuration from backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator restores the security server configuration from backup.&lt;/h3&gt; &lt;p&gt;This endpoint
    ///     can also return metadata in the error response. The metadata array contains the output of a failed backup restore
    ///     script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of TokensLoggedOut</returns>
    Task<TokensLoggedOut> RestoreBackupAsync(string filename, CancellationToken cancellationToken = default);

    /// <summary>
    ///     restore security server configuration from backup
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Administrator restores the security server configuration from backup.&lt;/h3&gt; &lt;p&gt;This endpoint
    ///     can also return metadata in the error response. The metadata array contains the output of a failed backup restore
    ///     script.&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (TokensLoggedOut)</returns>
    Task<ApiResponse<TokensLoggedOut>> RestoreBackupWithHttpInfoAsync(string filename,
        CancellationToken cancellationToken = default);

    /// <summary>
    ///     upload new backup for the security server
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Uploads new security server backup to the system.&lt;/h3&gt; &lt;p&gt;Note that it is possible to
    ///     overwrite an existing backup file with the same name. &lt;ul&gt; &lt;li&gt;Attempt to upload a new backup file
    ///     having the same name with an existing backup and with query parameter &lt;code&gt;ignore_warnings&lt;/code&gt;
    ///     &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;
    ///     Attempt to upload a new backup file having the same name with an existing backup and with query parameter &lt;code
    ///     &gt;ignore_warnings&lt;/code&gt; &#x3D; true will overwrite the existing backup.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    ///     &lt;p&gt;The warning response has a warning code &lt;code&gt;warning_file_already_exists&lt;/code&gt; and the
    ///     metadata field contains the name of the existing backup&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="ignoreWarnings">
    ///     If true, any ignorable warnings are ignored. if false (or missing), any warnings cause
    ///     request to fail. (optional, default to false)
    /// </param>
    /// <param name="file"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Backup</returns>
    Task<Backup> UploadBackupAsync(bool? ignoreWarnings = default, Stream file = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    ///     upload new backup for the security server
    /// </summary>
    /// <remarks>
    ///     &lt;h3&gt;Uploads new security server backup to the system.&lt;/h3&gt; &lt;p&gt;Note that it is possible to
    ///     overwrite an existing backup file with the same name. &lt;ul&gt; &lt;li&gt;Attempt to upload a new backup file
    ///     having the same name with an existing backup and with query parameter &lt;code&gt;ignore_warnings&lt;/code&gt;
    ///     &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;
    ///     Attempt to upload a new backup file having the same name with an existing backup and with query parameter &lt;code
    ///     &gt;ignore_warnings&lt;/code&gt; &#x3D; true will overwrite the existing backup.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    ///     &lt;p&gt;The warning response has a warning code &lt;code&gt;warning_file_already_exists&lt;/code&gt; and the
    ///     metadata field contains the name of the existing backup&lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="ignoreWarnings">
    ///     If true, any ignorable warnings are ignored. if false (or missing), any warnings cause
    ///     request to fail. (optional, default to false)
    /// </param>
    /// <param name="file"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Backup)</returns>
    Task<ApiResponse<Backup>> UploadBackupWithHttpInfoAsync(bool? ignoreWarnings = default, Stream file = default,
        CancellationToken cancellationToken = default);

    #endregion Asynchronous Operations
}

/// <summary>
///     Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface IBackupsApi : IBackupsApiSync, IBackupsApiAsync
{
}

/// <summary>
///     Represents a collection of functions to interact with the API endpoints
/// </summary>
public class BackupsApi : IBackupsApi
{
    private ExceptionFactory _exceptionFactory = (_, _) => null;

    /// <summary>
    ///     Initializes a new instance of the <see cref="BackupsApi" /> class.
    /// </summary>
    /// <returns></returns>
    public BackupsApi() : this((string) null)
    {
    }

    /// <summary>
    ///     Initializes a new instance of the <see cref="BackupsApi" /> class.
    /// </summary>
    /// <returns></returns>
    public BackupsApi(string basePath)
    {
        Configuration = Sdk.Client.Configuration.MergeConfigurations(
            GlobalConfiguration.Instance,
            new Configuration {BasePath = basePath}
        );
        Client = new ApiClient(Configuration.BasePath);
        AsynchronousClient = new ApiClient(Configuration.BasePath);
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    ///     Initializes a new instance of the <see cref="BackupsApi" /> class
    ///     using Configuration object
    /// </summary>
    /// <param name="configuration">An instance of Configuration</param>
    /// <returns></returns>
    public BackupsApi(Configuration configuration)
    {
        if (configuration == null) throw new ArgumentNullException("configuration");

        Configuration = Sdk.Client.Configuration.MergeConfigurations(
            GlobalConfiguration.Instance,
            configuration
        );
        Client = new ApiClient(Configuration.BasePath);
        AsynchronousClient = new ApiClient(Configuration.BasePath);
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    ///     Initializes a new instance of the <see cref="BackupsApi" /> class
    ///     using a Configuration object and client instance.
    /// </summary>
    /// <param name="client">The client interface for synchronous API access.</param>
    /// <param name="asyncClient">The client interface for asynchronous API access.</param>
    /// <param name="configuration">The configuration object.</param>
    public BackupsApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
    {
        Client = client ?? throw new ArgumentNullException(nameof(client), "Client parameter missing");
        AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient), "AsyncClient missing");
        Configuration = configuration ??
                        throw new ArgumentNullException(nameof(configuration), "Configuration missing");
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    ///     The client for accessing this underlying API asynchronously.
    /// </summary>
    public IAsynchronousClient AsynchronousClient { get; set; }

    /// <summary>
    ///     The client for accessing this underlying API synchronously.
    /// </summary>
    public ISynchronousClient Client { get; set; }

    /// <summary>
    ///     Gets the base path of the API client.
    /// </summary>
    /// <value>The base path</value>
    public string GetBasePath()
    {
        return Configuration.BasePath;
    }

    /// <summary>
    ///     Gets or sets the configuration object
    /// </summary>
    /// <value>An instance of the Configuration</value>
    public IReadableConfiguration Configuration { get; set; }

    /// <summary>
    ///     Provides a factory method hook for the creation of exceptions.
    /// </summary>
    public ExceptionFactory ExceptionFactory
    {
        get
        {
            if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
            return _exceptionFactory;
        }
        set => _exceptionFactory = value;
    }

    /// <summary>
    ///     add new backup for the security server &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;
    ///     This endpoint can also return metadata in the error response. The metadata array contains the output of a failed
    ///     backup generation script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>Backup</returns>
    public Backup AddBackup()
    {
        var localVarResponse = AddBackupWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    ///     add new backup for the security server &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;
    ///     This endpoint can also return metadata in the error response. The metadata array contains the output of a failed
    ///     backup generation script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of Backup</returns>
    public ApiResponse<Backup> AddBackupWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Post<Backup>("/backups", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("AddBackup", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     add new backup for the security server &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;
    ///     This endpoint can also return metadata in the error response. The metadata array contains the output of a failed
    ///     backup generation script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Backup</returns>
    public async Task<Backup> AddBackupAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse = await AddBackupWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    ///     add new backup for the security server &lt;h3&gt;Adds security server backup to the system.&lt;/h3&gt; &lt;p&gt;
    ///     This endpoint can also return metadata in the error response. The metadata array contains the output of a failed
    ///     backup generation script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Backup)</returns>
    public async Task<ApiResponse<Backup>> AddBackupWithHttpInfoAsync(CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<Backup>("/backups", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("AddBackup", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     add new backup for the security server and return extra backup state &lt;h3&gt;Adds security server backup to the
    ///     system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response. The metadata array
    ///     contains the output of a failed backup generation script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>BackupExt</returns>
    public BackupExt AddBackupExt()
    {
        var localVarResponse = AddBackupExtWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    ///     add new backup for the security server and return extra backup state &lt;h3&gt;Adds security server backup to the
    ///     system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response. The metadata array
    ///     contains the output of a failed backup generation script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of BackupExt</returns>
    public ApiResponse<BackupExt> AddBackupExtWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Post<BackupExt>("/backups/ext", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("AddBackupExt", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     add new backup for the security server and return extra backup state &lt;h3&gt;Adds security server backup to the
    ///     system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response. The metadata array
    ///     contains the output of a failed backup generation script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of BackupExt</returns>
    public async Task<BackupExt> AddBackupExtAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse = await AddBackupExtWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    ///     add new backup for the security server and return extra backup state &lt;h3&gt;Adds security server backup to the
    ///     system.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response. The metadata array
    ///     contains the output of a failed backup generation script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (BackupExt)</returns>
    public async Task<ApiResponse<BackupExt>> AddBackupExtWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<BackupExt>("/backups/ext", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("AddBackupExt", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     delete security server backup &lt;h3&gt;Administrator deletes the backup of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns></returns>
    public void DeleteBackup(string filename)
    {
        DeleteBackupWithHttpInfo(filename);
    }

    /// <summary>
    ///     delete security server backup &lt;h3&gt;Administrator deletes the backup of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>ApiResponse of Object(void)</returns>
    public ApiResponse<object> DeleteBackupWithHttpInfo(string filename)
    {
        // verify the required parameter 'filename' is set
        if (filename == null)
            throw new ApiException(400, "Missing required parameter 'filename' when calling BackupsApi->DeleteBackup");

        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        var accepts = Array.Empty<string>();

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("filename",
            ClientUtils.ParameterToString(filename)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Delete<object>("/backups/{filename}", localVarRequestOptions, Configuration);
        if (ExceptionFactory == null) return localVarResponse;
        if (ExceptionFactory("DeleteBackup", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     delete security server backup &lt;h3&gt;Administrator deletes the backup of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    public async Task DeleteBackupAsync(string filename, CancellationToken cancellationToken = default)
    {
        await DeleteBackupWithHttpInfoAsync(filename, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    ///     delete security server backup &lt;h3&gt;Administrator deletes the backup of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    public async Task<ApiResponse<object>> DeleteBackupWithHttpInfoAsync(string filename,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'filename' is set
        if (filename == null)
            throw new ApiException(400, "Missing required parameter 'filename' when calling BackupsApi->DeleteBackup");


        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        var accepts = Array.Empty<string>();

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("filename",
            ClientUtils.ParameterToString(filename)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .DeleteAsync<object>("/backups/{filename}", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("DeleteBackup", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     download security server backup &lt;h3&gt;Administrator downloads the backup of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>System.IO.Stream</returns>
    public Stream DownloadBackup(string filename)
    {
        var localVarResponse = DownloadBackupWithHttpInfo(filename);
        return localVarResponse.Data;
    }

    /// <summary>
    ///     download security server backup &lt;h3&gt;Administrator downloads the backup of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    public ApiResponse<Stream> DownloadBackupWithHttpInfo(string filename)
    {
        // verify the required parameter 'filename' is set
        if (filename == null)
            throw new ApiException(400,
                "Missing required parameter 'filename' when calling BackupsApi->DownloadBackup");

        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/octet-stream"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("filename",
            ClientUtils.ParameterToString(filename)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse =
            Client.Get<Stream>("/backups/{filename}/download", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("DownloadBackup", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     download security server backup &lt;h3&gt;Administrator downloads the backup of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    public async Task<Stream> DownloadBackupAsync(string filename, CancellationToken cancellationToken = default)
    {
        var localVarResponse = await DownloadBackupWithHttpInfoAsync(filename, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    ///     download security server backup &lt;h3&gt;Administrator downloads the backup of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    public async Task<ApiResponse<Stream>> DownloadBackupWithHttpInfoAsync(string filename,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'filename' is set
        if (filename == null)
            throw new ApiException(400,
                "Missing required parameter 'filename' when calling BackupsApi->DownloadBackup");


        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/octet-stream"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("filename",
            ClientUtils.ParameterToString(filename)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<Stream>("/backups/{filename}/download", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("DownloadBackup", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     get security server backups &lt;h3&gt;Administrator views the backups for the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>List&lt;Backup&gt;</returns>
    public List<Backup> GetBackups()
    {
        var localVarResponse = GetBackupsWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    ///     get security server backups &lt;h3&gt;Administrator views the backups for the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of List&lt;Backup&gt;</returns>
    public ApiResponse<List<Backup>> GetBackupsWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Get<List<Backup>>("/backups", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GetBackups", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     get security server backups &lt;h3&gt;Administrator views the backups for the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;Backup&gt;</returns>
    public async Task<List<Backup>> GetBackupsAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse = await GetBackupsWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    ///     get security server backups &lt;h3&gt;Administrator views the backups for the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;Backup&gt;)</returns>
    public async Task<ApiResponse<List<Backup>>> GetBackupsWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<List<Backup>>("/backups", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("GetBackups", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     restore security server configuration from backup &lt;h3&gt;Administrator restores the security server
    ///     configuration from backup.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response. The
    ///     metadata array contains the output of a failed backup restore script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>TokensLoggedOut</returns>
    public TokensLoggedOut RestoreBackup(string filename)
    {
        var localVarResponse = RestoreBackupWithHttpInfo(filename);
        return localVarResponse.Data;
    }

    /// <summary>
    ///     restore security server configuration from backup &lt;h3&gt;Administrator restores the security server
    ///     configuration from backup.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response. The
    ///     metadata array contains the output of a failed backup restore script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <returns>ApiResponse of TokensLoggedOut</returns>
    public ApiResponse<TokensLoggedOut> RestoreBackupWithHttpInfo(string filename)
    {
        // verify the required parameter 'filename' is set
        if (filename == null)
            throw new ApiException(400, "Missing required parameter 'filename' when calling BackupsApi->RestoreBackup");

        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("filename",
            ClientUtils.ParameterToString(filename)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse =
            Client.Put<TokensLoggedOut>("/backups/{filename}/restore", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("RestoreBackup", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     restore security server configuration from backup &lt;h3&gt;Administrator restores the security server
    ///     configuration from backup.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response. The
    ///     metadata array contains the output of a failed backup restore script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of TokensLoggedOut</returns>
    public async Task<TokensLoggedOut> RestoreBackupAsync(string filename,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse = await RestoreBackupWithHttpInfoAsync(filename, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    ///     restore security server configuration from backup &lt;h3&gt;Administrator restores the security server
    ///     configuration from backup.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response. The
    ///     metadata array contains the output of a failed backup restore script.&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="filename">filename of the backup</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (TokensLoggedOut)</returns>
    public async Task<ApiResponse<TokensLoggedOut>> RestoreBackupWithHttpInfoAsync(string filename,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'filename' is set
        if (filename == null)
            throw new ApiException(400, "Missing required parameter 'filename' when calling BackupsApi->RestoreBackup");


        var localVarRequestOptions = new RequestOptions();

        var contentTypes = Array.Empty<string>();

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("filename",
            ClientUtils.ParameterToString(filename)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PutAsync<TokensLoggedOut>("/backups/{filename}/restore", localVarRequestOptions, Configuration,
                cancellationToken).ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("RestoreBackup", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     upload new backup for the security server &lt;h3&gt;Uploads new security server backup to the system.&lt;/h3&gt;
    ///     &lt;p&gt;Note that it is possible to overwrite an existing backup file with the same name. &lt;ul&gt; &lt;li&gt;
    ///     Attempt to upload a new backup file having the same name with an existing backup and with query parameter &lt;code
    ///     &gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s
    ///     ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to upload a new backup file having the same name with an existing
    ///     backup and with query parameter &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true will overwrite the existing
    ///     backup.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; &lt;p&gt;The warning response has a warning code &lt;code&gt;
    ///     warning_file_already_exists&lt;/code&gt; and the metadata field contains the name of the existing backup&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="ignoreWarnings">
    ///     If true, any ignorable warnings are ignored. if false (or missing), any warnings cause
    ///     request to fail. (optional, default to false)
    /// </param>
    /// <param name="file"> (optional)</param>
    /// <returns>Backup</returns>
    public Backup UploadBackup(bool? ignoreWarnings = default, Stream file = default)
    {
        var localVarResponse = UploadBackupWithHttpInfo(ignoreWarnings, file);
        return localVarResponse.Data;
    }

    /// <summary>
    ///     upload new backup for the security server &lt;h3&gt;Uploads new security server backup to the system.&lt;/h3&gt;
    ///     &lt;p&gt;Note that it is possible to overwrite an existing backup file with the same name. &lt;ul&gt; &lt;li&gt;
    ///     Attempt to upload a new backup file having the same name with an existing backup and with query parameter &lt;code
    ///     &gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s
    ///     ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to upload a new backup file having the same name with an existing
    ///     backup and with query parameter &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true will overwrite the existing
    ///     backup.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; &lt;p&gt;The warning response has a warning code &lt;code&gt;
    ///     warning_file_already_exists&lt;/code&gt; and the metadata field contains the name of the existing backup&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="ignoreWarnings">
    ///     If true, any ignorable warnings are ignored. if false (or missing), any warnings cause
    ///     request to fail. (optional, default to false)
    /// </param>
    /// <param name="file"> (optional)</param>
    /// <returns>ApiResponse of Backup</returns>
    public ApiResponse<Backup> UploadBackupWithHttpInfo(bool? ignoreWarnings = default, Stream file = default)
    {
        var localVarRequestOptions = new RequestOptions();

        string[] contentTypes =
        {
            "multipart/form-data"
        };

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        if (ignoreWarnings != null)
            localVarRequestOptions.QueryParameters.Add(
                ClientUtils.ParameterToMultiMap("", "ignore_warnings", ignoreWarnings));
        if (file != null) localVarRequestOptions.FileParameters.Add("file", file);

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Post<Backup>("/backups/upload", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("UploadBackup", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    ///     upload new backup for the security server &lt;h3&gt;Uploads new security server backup to the system.&lt;/h3&gt;
    ///     &lt;p&gt;Note that it is possible to overwrite an existing backup file with the same name. &lt;ul&gt; &lt;li&gt;
    ///     Attempt to upload a new backup file having the same name with an existing backup and with query parameter &lt;code
    ///     &gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s
    ///     ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to upload a new backup file having the same name with an existing
    ///     backup and with query parameter &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true will overwrite the existing
    ///     backup.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; &lt;p&gt;The warning response has a warning code &lt;code&gt;
    ///     warning_file_already_exists&lt;/code&gt; and the metadata field contains the name of the existing backup&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="ignoreWarnings">
    ///     If true, any ignorable warnings are ignored. if false (or missing), any warnings cause
    ///     request to fail. (optional, default to false)
    /// </param>
    /// <param name="file"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Backup</returns>
    public async Task<Backup> UploadBackupAsync(bool? ignoreWarnings = default, Stream file = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse = await UploadBackupWithHttpInfoAsync(ignoreWarnings, file, cancellationToken)
            .ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    ///     upload new backup for the security server &lt;h3&gt;Uploads new security server backup to the system.&lt;/h3&gt;
    ///     &lt;p&gt;Note that it is possible to overwrite an existing backup file with the same name. &lt;ul&gt; &lt;li&gt;
    ///     Attempt to upload a new backup file having the same name with an existing backup and with query parameter &lt;code
    ///     &gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s
    ///     ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to upload a new backup file having the same name with an existing
    ///     backup and with query parameter &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true will overwrite the existing
    ///     backup.&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt; &lt;p&gt;The warning response has a warning code &lt;code&gt;
    ///     warning_file_already_exists&lt;/code&gt; and the metadata field contains the name of the existing backup&lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="ignoreWarnings">
    ///     If true, any ignorable warnings are ignored. if false (or missing), any warnings cause
    ///     request to fail. (optional, default to false)
    /// </param>
    /// <param name="file"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Backup)</returns>
    public async Task<ApiResponse<Backup>> UploadBackupWithHttpInfoAsync(bool? ignoreWarnings = default,
        Stream file = default, CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();

        string[] contentTypes =
        {
            "multipart/form-data"
        };

        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(contentTypes);
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        if (ignoreWarnings != null)
            localVarRequestOptions.QueryParameters.Add(
                ClientUtils.ParameterToMultiMap("", "ignore_warnings", ignoreWarnings));
        if (file != null) localVarRequestOptions.FileParameters.Add("file", file);

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<Backup>("/backups/upload", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("UploadBackup", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }
}