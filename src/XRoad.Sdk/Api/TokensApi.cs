/*
 * X-Road Security Server Admin API
 *
 * X-Road Security Server Admin API. Note that the error metadata responses described in some endpoints are subjects to change and may be updated in upcoming versions.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@niis.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using XRoad.Sdk.Client;
using XRoad.Sdk.Model;

namespace XRoad.Sdk.Api;

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface ITokensApiSync : IApiAccessor
{
    #region Synchronous Operations

    /// <summary>
    /// add new key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Adds key for selected token.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabel"> (optional)</param>
    /// <returns>Key</returns>
    Key AddKey(string id, KeyLabel keyLabel = default);

    /// <summary>
    /// add new key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Adds key for selected token.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabel"> (optional)</param>
    /// <returns>ApiResponse of Key</returns>
    ApiResponse<Key> AddKeyWithHttpInfo(string id, KeyLabel keyLabel = default);

    /// <summary>
    /// add a new key and generate a csr for it
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator adds a new key and generates a csr for it.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabelWithCsrGenerate"> (optional)</param>
    /// <returns>KeyWithCertificateSigningRequestId</returns>
    KeyWithCertificateSigningRequestId AddKeyAndCsr(string id,
        KeyLabelWithCsrGenerate keyLabelWithCsrGenerate = default);

    /// <summary>
    /// add a new key and generate a csr for it
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator adds a new key and generates a csr for it.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabelWithCsrGenerate"> (optional)</param>
    /// <returns>ApiResponse of KeyWithCertificateSigningRequestId</returns>
    ApiResponse<KeyWithCertificateSigningRequestId> AddKeyAndCsrWithHttpInfo(string id,
        KeyLabelWithCsrGenerate keyLabelWithCsrGenerate = default);

    /// <summary>
    /// get security server token information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the token details of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <returns>Token</returns>
    Token GetToken(string id);

    /// <summary>
    /// get security server token information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the token details of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <returns>ApiResponse of Token</returns>
    ApiResponse<Token> GetTokenWithHttpInfo(string id);

    /// <summary>
    /// get security server tokens
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views tokens of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>List&lt;Token&gt;</returns>
    List<Token> GetTokens();

    /// <summary>
    /// get security server tokens
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views tokens of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of List&lt;Token&gt;</returns>
    ApiResponse<List<Token>> GetTokensWithHttpInfo();

    /// <summary>
    /// login to token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator logs in to a token&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenPassword"> (optional)</param>
    /// <returns>Token</returns>
    Token LoginToken(string id, TokenPassword tokenPassword = default);

    /// <summary>
    /// login to token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator logs in to a token&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenPassword"> (optional)</param>
    /// <returns>ApiResponse of Token</returns>
    ApiResponse<Token> LoginTokenWithHttpInfo(string id, TokenPassword tokenPassword = default);

    /// <summary>
    /// logout from token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator logs out from token.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <returns>Token</returns>
    Token LogoutToken(string id);

    /// <summary>
    /// logout from token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator logs out from token.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <returns>ApiResponse of Token</returns>
    ApiResponse<Token> LogoutTokenWithHttpInfo(string id);

    /// <summary>
    /// update security server token information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the token information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenName"> (optional)</param>
    /// <returns>Token</returns>
    Token UpdateToken(string id, TokenName tokenName = default);

    /// <summary>
    /// update security server token information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the token information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenName"> (optional)</param>
    /// <returns>ApiResponse of Token</returns>
    ApiResponse<Token> UpdateTokenWithHttpInfo(string id, TokenName tokenName = default);

    /// <summary>
    /// update security server software token pin code
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the software token pin code.&lt;/h3&gt; &lt;p&gt;This operation supports updating the pin code of a software token only.&lt;/p&gt; &lt;p&gt; This endpoint can also return metadata in the error response. The metadata array can contain error messages about why the init did not succeed. If the pin code is too weak, the error code &lt;code&gt;weak_pin&lt;/code&gt; is used and the entries in the metadata array are always ordered in following way &lt;ul&gt; &lt;li&gt;metadata has a list of strings [\&quot;pin_min_length\&quot;, x, \&quot;pin_min_char_classes_count\&quot;, y] where&lt;/li&gt; &lt;li&gt;x &#x3D; the minimum length of the pin code&lt;/li&gt; &lt;li&gt;y &#x3D; the minimum amount of character classes (e.g. uppercase, number, special characters) to be used in the pin code&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the software token</param>
    /// <param name="tokenPinUpdate"> (optional)</param>
    /// <returns></returns>
    void UpdateTokenPin(string id, TokenPinUpdate tokenPinUpdate = default);

    /// <summary>
    /// update security server software token pin code
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the software token pin code.&lt;/h3&gt; &lt;p&gt;This operation supports updating the pin code of a software token only.&lt;/p&gt; &lt;p&gt; This endpoint can also return metadata in the error response. The metadata array can contain error messages about why the init did not succeed. If the pin code is too weak, the error code &lt;code&gt;weak_pin&lt;/code&gt; is used and the entries in the metadata array are always ordered in following way &lt;ul&gt; &lt;li&gt;metadata has a list of strings [\&quot;pin_min_length\&quot;, x, \&quot;pin_min_char_classes_count\&quot;, y] where&lt;/li&gt; &lt;li&gt;x &#x3D; the minimum length of the pin code&lt;/li&gt; &lt;li&gt;y &#x3D; the minimum amount of character classes (e.g. uppercase, number, special characters) to be used in the pin code&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the software token</param>
    /// <param name="tokenPinUpdate"> (optional)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    ApiResponse<object> UpdateTokenPinWithHttpInfo(string id, TokenPinUpdate tokenPinUpdate = default);

    #endregion Synchronous Operations
}

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface ITokensApiAsync : IApiAccessor
{
    #region Asynchronous Operations

    /// <summary>
    /// add new key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Adds key for selected token.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabel"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Key</returns>
    Task<Key> AddKeyAsync(string id, KeyLabel keyLabel = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// add new key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Adds key for selected token.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabel"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Key)</returns>
    Task<ApiResponse<Key>> AddKeyWithHttpInfoAsync(string id, KeyLabel keyLabel = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// add a new key and generate a csr for it
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator adds a new key and generates a csr for it.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabelWithCsrGenerate"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of KeyWithCertificateSigningRequestId</returns>
    Task<KeyWithCertificateSigningRequestId> AddKeyAndCsrAsync(string id,
        KeyLabelWithCsrGenerate keyLabelWithCsrGenerate = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// add a new key and generate a csr for it
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator adds a new key and generates a csr for it.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabelWithCsrGenerate"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (KeyWithCertificateSigningRequestId)</returns>
    Task<ApiResponse<KeyWithCertificateSigningRequestId>> AddKeyAndCsrWithHttpInfoAsync(string id,
        KeyLabelWithCsrGenerate keyLabelWithCsrGenerate = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// get security server token information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the token details of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Token</returns>
    Task<Token> GetTokenAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// get security server token information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views the token details of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Token)</returns>
    Task<ApiResponse<Token>> GetTokenWithHttpInfoAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// get security server tokens
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views tokens of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;Token&gt;</returns>
    Task<List<Token>> GetTokensAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// get security server tokens
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views tokens of the security server.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;Token&gt;)</returns>
    Task<ApiResponse<List<Token>>> GetTokensWithHttpInfoAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// login to token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator logs in to a token&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenPassword"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Token</returns>
    Task<Token> LoginTokenAsync(string id, TokenPassword tokenPassword = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// login to token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator logs in to a token&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenPassword"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Token)</returns>
    Task<ApiResponse<Token>> LoginTokenWithHttpInfoAsync(string id, TokenPassword tokenPassword = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// logout from token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator logs out from token.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Token</returns>
    Task<Token> LogoutTokenAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// logout from token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator logs out from token.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Token)</returns>
    Task<ApiResponse<Token>> LogoutTokenWithHttpInfoAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// update security server token information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the token information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Token</returns>
    Task<Token> UpdateTokenAsync(string id, TokenName tokenName = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// update security server token information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the token information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Token)</returns>
    Task<ApiResponse<Token>> UpdateTokenWithHttpInfoAsync(string id, TokenName tokenName = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// update security server software token pin code
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the software token pin code.&lt;/h3&gt; &lt;p&gt;This operation supports updating the pin code of a software token only.&lt;/p&gt; &lt;p&gt; This endpoint can also return metadata in the error response. The metadata array can contain error messages about why the init did not succeed. If the pin code is too weak, the error code &lt;code&gt;weak_pin&lt;/code&gt; is used and the entries in the metadata array are always ordered in following way &lt;ul&gt; &lt;li&gt;metadata has a list of strings [\&quot;pin_min_length\&quot;, x, \&quot;pin_min_char_classes_count\&quot;, y] where&lt;/li&gt; &lt;li&gt;x &#x3D; the minimum length of the pin code&lt;/li&gt; &lt;li&gt;y &#x3D; the minimum amount of character classes (e.g. uppercase, number, special characters) to be used in the pin code&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the software token</param>
    /// <param name="tokenPinUpdate"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    Task UpdateTokenPinAsync(string id, TokenPinUpdate tokenPinUpdate = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// update security server software token pin code
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the software token pin code.&lt;/h3&gt; &lt;p&gt;This operation supports updating the pin code of a software token only.&lt;/p&gt; &lt;p&gt; This endpoint can also return metadata in the error response. The metadata array can contain error messages about why the init did not succeed. If the pin code is too weak, the error code &lt;code&gt;weak_pin&lt;/code&gt; is used and the entries in the metadata array are always ordered in following way &lt;ul&gt; &lt;li&gt;metadata has a list of strings [\&quot;pin_min_length\&quot;, x, \&quot;pin_min_char_classes_count\&quot;, y] where&lt;/li&gt; &lt;li&gt;x &#x3D; the minimum length of the pin code&lt;/li&gt; &lt;li&gt;y &#x3D; the minimum amount of character classes (e.g. uppercase, number, special characters) to be used in the pin code&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the software token</param>
    /// <param name="tokenPinUpdate"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    Task<ApiResponse<object>> UpdateTokenPinWithHttpInfoAsync(string id, TokenPinUpdate tokenPinUpdate = default,
        CancellationToken cancellationToken = default);

    #endregion Asynchronous Operations
}

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface ITokensApi : ITokensApiSync, ITokensApiAsync
{
}

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public class TokensApi : ITokensApi
{
    private ExceptionFactory _exceptionFactory = (name, response) => null;

    /// <summary>
    /// Initializes a new instance of the <see cref="TokensApi"/> class.
    /// </summary>
    /// <returns></returns>
    public TokensApi() : this((string) null)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TokensApi"/> class.
    /// </summary>
    /// <returns></returns>
    public TokensApi(string basePath)
    {
        Configuration = Sdk.Client.Configuration.MergeConfigurations(
            GlobalConfiguration.Instance,
            new Configuration {BasePath = basePath}
        );
        Client = new ApiClient(Configuration.BasePath);
        AsynchronousClient = new ApiClient(Configuration.BasePath);
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TokensApi"/> class
    /// using Configuration object
    /// </summary>
    /// <param name="configuration">An instance of Configuration</param>
    /// <returns></returns>
    public TokensApi(Configuration configuration)
    {
        if (configuration == null) throw new ArgumentNullException("configuration");

        Configuration = Sdk.Client.Configuration.MergeConfigurations(
            GlobalConfiguration.Instance,
            configuration
        );
        Client = new ApiClient(Configuration.BasePath);
        AsynchronousClient = new ApiClient(Configuration.BasePath);
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="TokensApi"/> class
    /// using a Configuration object and client instance.
    /// </summary>
    /// <param name="client">The client interface for synchronous API access.</param>
    /// <param name="asyncClient">The client interface for asynchronous API access.</param>
    /// <param name="configuration">The configuration object.</param>
    public TokensApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
    {
        Client = client ?? throw new ArgumentNullException(nameof(client),"client");
        AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient),"asyncClient");
        Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration),"configuration");
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// The client for accessing this underlying API asynchronously.
    /// </summary>
    public IAsynchronousClient AsynchronousClient { get; set; }

    /// <summary>
    /// The client for accessing this underlying API synchronously.
    /// </summary>
    public ISynchronousClient Client { get; set; }

    /// <summary>
    /// Gets the base path of the API client.
    /// </summary>
    /// <value>The base path</value>
    public string GetBasePath()
    {
        return Configuration.BasePath;
    }

    /// <summary>
    /// Gets or sets the configuration object
    /// </summary>
    /// <value>An instance of the Configuration</value>
    public IReadableConfiguration Configuration { get; set; }

    /// <summary>
    /// Provides a factory method hook for the creation of exceptions.
    /// </summary>
    public ExceptionFactory ExceptionFactory
    {
        get
        {
            if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
            return _exceptionFactory;
        }
        set => _exceptionFactory = value;
    }

    /// <summary>
    /// add new key &lt;h3&gt;Adds key for selected token.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabel"> (optional)</param>
    /// <returns>Key</returns>
    public Key AddKey(string id, KeyLabel keyLabel = default)
    {
        var localVarResponse = AddKeyWithHttpInfo(id, keyLabel);
        return localVarResponse.Data;
    }

    /// <summary>
    /// add new key &lt;h3&gt;Adds key for selected token.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabel"> (optional)</param>
    /// <returns>ApiResponse of Key</returns>
    public ApiResponse<Key> AddKeyWithHttpInfo(string id, KeyLabel keyLabel = default)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->AddKey");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = keyLabel;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Post<Key>("/tokens/{id}/keys", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("AddKey", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// add new key &lt;h3&gt;Adds key for selected token.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabel"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Key</returns>
    public async Task<Key> AddKeyAsync(string id, KeyLabel keyLabel = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse = await AddKeyWithHttpInfoAsync(id, keyLabel, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// add new key &lt;h3&gt;Adds key for selected token.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabel"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Key)</returns>
    public async Task<ApiResponse<Key>> AddKeyWithHttpInfoAsync(string id, KeyLabel keyLabel = default,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->AddKey");


        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = keyLabel;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<Key>("/tokens/{id}/keys", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("AddKey", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// add a new key and generate a csr for it &lt;h3&gt;Administrator adds a new key and generates a csr for it.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabelWithCsrGenerate"> (optional)</param>
    /// <returns>KeyWithCertificateSigningRequestId</returns>
    public KeyWithCertificateSigningRequestId AddKeyAndCsr(string id,
        KeyLabelWithCsrGenerate keyLabelWithCsrGenerate = default)
    {
        var localVarResponse = AddKeyAndCsrWithHttpInfo(id, keyLabelWithCsrGenerate);
        return localVarResponse.Data;
    }

    /// <summary>
    /// add a new key and generate a csr for it &lt;h3&gt;Administrator adds a new key and generates a csr for it.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabelWithCsrGenerate"> (optional)</param>
    /// <returns>ApiResponse of KeyWithCertificateSigningRequestId</returns>
    public ApiResponse<KeyWithCertificateSigningRequestId> AddKeyAndCsrWithHttpInfo(string id,
        KeyLabelWithCsrGenerate keyLabelWithCsrGenerate = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->AddKeyAndCsr");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = keyLabelWithCsrGenerate;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Post<KeyWithCertificateSigningRequestId>("/tokens/{id}/keys-with-csrs",
            localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("AddKeyAndCsr", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// add a new key and generate a csr for it &lt;h3&gt;Administrator adds a new key and generates a csr for it.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabelWithCsrGenerate"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of KeyWithCertificateSigningRequestId</returns>
    public async Task<KeyWithCertificateSigningRequestId> AddKeyAndCsrAsync(string id,
        KeyLabelWithCsrGenerate keyLabelWithCsrGenerate = default, CancellationToken cancellationToken = default)
    {
        var localVarResponse = await AddKeyAndCsrWithHttpInfoAsync(id, keyLabelWithCsrGenerate, cancellationToken)
            .ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// add a new key and generate a csr for it &lt;h3&gt;Administrator adds a new key and generates a csr for it.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="keyLabelWithCsrGenerate"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (KeyWithCertificateSigningRequestId)</returns>
    public async Task<ApiResponse<KeyWithCertificateSigningRequestId>> AddKeyAndCsrWithHttpInfoAsync(string id,
        KeyLabelWithCsrGenerate keyLabelWithCsrGenerate = default, CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->AddKeyAndCsr");


        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = keyLabelWithCsrGenerate;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<KeyWithCertificateSigningRequestId>("/tokens/{id}/keys-with-csrs", localVarRequestOptions,
                Configuration, cancellationToken).ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("AddKeyAndCsr", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get security server token information &lt;h3&gt;Administrator views the token details of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <returns>Token</returns>
    public Token GetToken(string id)
    {
        var localVarResponse = GetTokenWithHttpInfo(id);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get security server token information &lt;h3&gt;Administrator views the token details of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <returns>ApiResponse of Token</returns>
    public ApiResponse<Token> GetTokenWithHttpInfo(string id)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->GetToken");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Get<Token>("/tokens/{id}", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GetToken", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get security server token information &lt;h3&gt;Administrator views the token details of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Token</returns>
    public async Task<Token> GetTokenAsync(string id, CancellationToken cancellationToken = default)
    {
        var localVarResponse = await GetTokenWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get security server token information &lt;h3&gt;Administrator views the token details of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Token)</returns>
    public async Task<ApiResponse<Token>> GetTokenWithHttpInfoAsync(string id,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->GetToken");


        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<Token>("/tokens/{id}", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("GetToken", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get security server tokens &lt;h3&gt;Administrator views tokens of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>List&lt;Token&gt;</returns>
    public List<Token> GetTokens()
    {
        var localVarResponse = GetTokensWithHttpInfo();
        return localVarResponse.Data;
    }

    /// <summary>
    /// get security server tokens &lt;h3&gt;Administrator views tokens of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <returns>ApiResponse of List&lt;Token&gt;</returns>
    public ApiResponse<List<Token>> GetTokensWithHttpInfo()
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Get<List<Token>>("/tokens", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GetTokens", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get security server tokens &lt;h3&gt;Administrator views tokens of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;Token&gt;</returns>
    public async Task<List<Token>> GetTokensAsync(CancellationToken cancellationToken = default)
    {
        var localVarResponse = await GetTokensWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get security server tokens &lt;h3&gt;Administrator views tokens of the security server.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;Token&gt;)</returns>
    public async Task<ApiResponse<List<Token>>> GetTokensWithHttpInfoAsync(
        CancellationToken cancellationToken = default)
    {
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);


        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<List<Token>>("/tokens", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("GetTokens", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// login to token &lt;h3&gt;Administrator logs in to a token&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenPassword"> (optional)</param>
    /// <returns>Token</returns>
    public Token LoginToken(string id, TokenPassword tokenPassword = default)
    {
        var localVarResponse = LoginTokenWithHttpInfo(id, tokenPassword);
        return localVarResponse.Data;
    }

    /// <summary>
    /// login to token &lt;h3&gt;Administrator logs in to a token&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenPassword"> (optional)</param>
    /// <returns>ApiResponse of Token</returns>
    public ApiResponse<Token> LoginTokenWithHttpInfo(string id, TokenPassword tokenPassword = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->LoginToken");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = tokenPassword;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Put<Token>("/tokens/{id}/login", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("LoginToken", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// login to token &lt;h3&gt;Administrator logs in to a token&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenPassword"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Token</returns>
    public async Task<Token> LoginTokenAsync(string id, TokenPassword tokenPassword = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse =
            await LoginTokenWithHttpInfoAsync(id, tokenPassword, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// login to token &lt;h3&gt;Administrator logs in to a token&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenPassword"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Token)</returns>
    public async Task<ApiResponse<Token>> LoginTokenWithHttpInfoAsync(string id, TokenPassword tokenPassword = default,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->LoginToken");


        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = tokenPassword;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PutAsync<Token>("/tokens/{id}/login", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("LoginToken", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// logout from token &lt;h3&gt;Administrator logs out from token.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <returns>Token</returns>
    public Token LogoutToken(string id)
    {
        var localVarResponse = LogoutTokenWithHttpInfo(id);
        return localVarResponse.Data;
    }

    /// <summary>
    /// logout from token &lt;h3&gt;Administrator logs out from token.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <returns>ApiResponse of Token</returns>
    public ApiResponse<Token> LogoutTokenWithHttpInfo(string id)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->LogoutToken");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Put<Token>("/tokens/{id}/logout", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("LogoutToken", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// logout from token &lt;h3&gt;Administrator logs out from token.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Token</returns>
    public async Task<Token> LogoutTokenAsync(string id, CancellationToken cancellationToken = default)
    {
        var localVarResponse = await LogoutTokenWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// logout from token &lt;h3&gt;Administrator logs out from token.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Token)</returns>
    public async Task<ApiResponse<Token>> LogoutTokenWithHttpInfoAsync(string id,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->LogoutToken");


        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PutAsync<Token>("/tokens/{id}/logout", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("LogoutToken", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// update security server token information &lt;h3&gt;Administrator updates the token information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenName"> (optional)</param>
    /// <returns>Token</returns>
    public Token UpdateToken(string id, TokenName tokenName = default)
    {
        var localVarResponse = UpdateTokenWithHttpInfo(id, tokenName);
        return localVarResponse.Data;
    }

    /// <summary>
    /// update security server token information &lt;h3&gt;Administrator updates the token information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenName"> (optional)</param>
    /// <returns>ApiResponse of Token</returns>
    public ApiResponse<Token> UpdateTokenWithHttpInfo(string id, TokenName tokenName = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->UpdateToken");
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = tokenName;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Patch<Token>("/tokens/{id}", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("UpdateToken", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// update security server token information &lt;h3&gt;Administrator updates the token information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Token</returns>
    public async Task<Token> UpdateTokenAsync(string id, TokenName tokenName = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse =
            await UpdateTokenWithHttpInfoAsync(id, tokenName, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// update security server token information &lt;h3&gt;Administrator updates the token information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the token</param>
    /// <param name="tokenName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Token)</returns>
    public async Task<ApiResponse<Token>> UpdateTokenWithHttpInfoAsync(string id, TokenName tokenName = default,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->UpdateToken");
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = tokenName;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PatchAsync<Token>("/tokens/{id}", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("UpdateToken", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// update security server software token pin code &lt;h3&gt;Administrator updates the software token pin code.&lt;/h3&gt; &lt;p&gt;This operation supports updating the pin code of a software token only.&lt;/p&gt; &lt;p&gt; This endpoint can also return metadata in the error response. The metadata array can contain error messages about why the init did not succeed. If the pin code is too weak, the error code &lt;code&gt;weak_pin&lt;/code&gt; is used and the entries in the metadata array are always ordered in following way &lt;ul&gt; &lt;li&gt;metadata has a list of strings [\&quot;pin_min_length\&quot;, x, \&quot;pin_min_char_classes_count\&quot;, y] where&lt;/li&gt; &lt;li&gt;x &#x3D; the minimum length of the pin code&lt;/li&gt; &lt;li&gt;y &#x3D; the minimum amount of character classes (e.g. uppercase, number, special characters) to be used in the pin code&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the software token</param>
    /// <param name="tokenPinUpdate"> (optional)</param>
    /// <returns></returns>
    public void UpdateTokenPin(string id, TokenPinUpdate tokenPinUpdate = default)
    {
        UpdateTokenPinWithHttpInfo(id, tokenPinUpdate);
    }

    /// <summary>
    /// update security server software token pin code &lt;h3&gt;Administrator updates the software token pin code.&lt;/h3&gt; &lt;p&gt;This operation supports updating the pin code of a software token only.&lt;/p&gt; &lt;p&gt; This endpoint can also return metadata in the error response. The metadata array can contain error messages about why the init did not succeed. If the pin code is too weak, the error code &lt;code&gt;weak_pin&lt;/code&gt; is used and the entries in the metadata array are always ordered in following way &lt;ul&gt; &lt;li&gt;metadata has a list of strings [\&quot;pin_min_length\&quot;, x, \&quot;pin_min_char_classes_count\&quot;, y] where&lt;/li&gt; &lt;li&gt;x &#x3D; the minimum length of the pin code&lt;/li&gt; &lt;li&gt;y &#x3D; the minimum amount of character classes (e.g. uppercase, number, special characters) to be used in the pin code&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the software token</param>
    /// <param name="tokenPinUpdate"> (optional)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    public ApiResponse<object> UpdateTokenPinWithHttpInfo(string id, TokenPinUpdate tokenPinUpdate = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->UpdateTokenPin");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = tokenPinUpdate;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Put<object>("/tokens/{id}/pin", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("UpdateTokenPin", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// update security server software token pin code &lt;h3&gt;Administrator updates the software token pin code.&lt;/h3&gt; &lt;p&gt;This operation supports updating the pin code of a software token only.&lt;/p&gt; &lt;p&gt; This endpoint can also return metadata in the error response. The metadata array can contain error messages about why the init did not succeed. If the pin code is too weak, the error code &lt;code&gt;weak_pin&lt;/code&gt; is used and the entries in the metadata array are always ordered in following way &lt;ul&gt; &lt;li&gt;metadata has a list of strings [\&quot;pin_min_length\&quot;, x, \&quot;pin_min_char_classes_count\&quot;, y] where&lt;/li&gt; &lt;li&gt;x &#x3D; the minimum length of the pin code&lt;/li&gt; &lt;li&gt;y &#x3D; the minimum amount of character classes (e.g. uppercase, number, special characters) to be used in the pin code&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the software token</param>
    /// <param name="tokenPinUpdate"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    public async Task UpdateTokenPinAsync(string id, TokenPinUpdate tokenPinUpdate = default,
        CancellationToken cancellationToken = default)
    {
        await UpdateTokenPinWithHttpInfoAsync(id, tokenPinUpdate, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// update security server software token pin code &lt;h3&gt;Administrator updates the software token pin code.&lt;/h3&gt; &lt;p&gt;This operation supports updating the pin code of a software token only.&lt;/p&gt; &lt;p&gt; This endpoint can also return metadata in the error response. The metadata array can contain error messages about why the init did not succeed. If the pin code is too weak, the error code &lt;code&gt;weak_pin&lt;/code&gt; is used and the entries in the metadata array are always ordered in following way &lt;ul&gt; &lt;li&gt;metadata has a list of strings [\&quot;pin_min_length\&quot;, x, \&quot;pin_min_char_classes_count\&quot;, y] where&lt;/li&gt; &lt;li&gt;x &#x3D; the minimum length of the pin code&lt;/li&gt; &lt;li&gt;y &#x3D; the minimum amount of character classes (e.g. uppercase, number, special characters) to be used in the pin code&lt;/li&gt; &lt;/ul&gt; &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the software token</param>
    /// <param name="tokenPinUpdate"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    public async Task<ApiResponse<object>> UpdateTokenPinWithHttpInfoAsync(string id,
        TokenPinUpdate tokenPinUpdate = default, CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling TokensApi->UpdateTokenPin");


        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new []{"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new []{"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = tokenPinUpdate;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PutAsync<object>("/tokens/{id}/pin", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("UpdateTokenPin", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }
}