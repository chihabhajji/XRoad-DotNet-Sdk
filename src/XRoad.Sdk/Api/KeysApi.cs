/*
 * X-Road Security Server Admin API
 *
 * X-Road Security Server Admin API. Note that the error metadata responses described in some endpoints are subjects to change and may be updated in upcoming versions.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: info@niis.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using XRoad.Sdk.Client;
using XRoad.Sdk.Model;

namespace XRoad.Sdk.Api;

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface IKeysApiSync : IApiAccessor
{
    #region Synchronous Operations

    /// <summary>
    /// delete csr from the selected key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator deletes csr from the key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <returns></returns>
    void DeleteCsr(string id, string csrId);

    /// <summary>
    /// delete csr from the selected key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator deletes csr from the key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <returns>ApiResponse of Object(void)</returns>
    ApiResponse<object> DeleteCsrWithHttpInfo(string id, string csrId);

    /// <summary>
    /// delete key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator deletes the key.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response if sending an auth cert deletion management request fails. The metadata array contains the error details that were generated in core. The message is in plain English.&lt;/p&gt; &lt;p&gt; Note that with this endpoint it&#39;s possible to delete an authentication key with a registered authentication certificate. &lt;ul&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true succeeds. The authentication certificate is first unregistered, and the key and certificate are deleted after that.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;When trying to delete an authentication key with a registered authentication certificate, the warning response has a warning code &lt;code&gt;auth_key_with_registered_cert_warning&lt;/code&gt; and the metadata field contains the key id of the key&lt;/p&gt; &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="ignoreWarnings">if true, any ignorable warnings are ignored. if false (or missing), any warnings cause request to fail (optional, default to false)</param>
    /// <returns></returns>
    void DeleteKey(string id, bool? ignoreWarnings = default);

    /// <summary>
    /// delete key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator deletes the key.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response if sending an auth cert deletion management request fails. The metadata array contains the error details that were generated in core. The message is in plain English.&lt;/p&gt; &lt;p&gt; Note that with this endpoint it&#39;s possible to delete an authentication key with a registered authentication certificate. &lt;ul&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true succeeds. The authentication certificate is first unregistered, and the key and certificate are deleted after that.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;When trying to delete an authentication key with a registered authentication certificate, the warning response has a warning code &lt;code&gt;auth_key_with_registered_cert_warning&lt;/code&gt; and the metadata field contains the key id of the key&lt;/p&gt; &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="ignoreWarnings">if true, any ignorable warnings are ignored. if false (or missing), any warnings cause request to fail (optional, default to false)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    ApiResponse<object> DeleteKeyWithHttpInfo(string id, bool? ignoreWarnings = default);

    /// <summary>
    /// download a CSR binary
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads a csr that has been created earlier.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="csrFormat">format of the certificate signing request (PEM or DER) (optional)</param>
    /// <returns>System.IO.Stream</returns>
    Stream DownloadCsr(string id, string csrId, CsrFormat? csrFormat = default);

    /// <summary>
    /// download a CSR binary
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads a csr that has been created earlier.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="csrFormat">format of the certificate signing request (PEM or DER) (optional)</param>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    ApiResponse<Stream> DownloadCsrWithHttpInfo(string id, string csrId, CsrFormat? csrFormat = default);

    /// <summary>
    /// generate csr for the selected key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates csr for the key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrGenerate">request to generate csr (optional)</param>
    /// <returns>System.IO.Stream</returns>
    Stream GenerateCsr(string id, CsrGenerate csrGenerate = default);

    /// <summary>
    /// generate csr for the selected key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates csr for the key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrGenerate">request to generate csr (optional)</param>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    ApiResponse<Stream> GenerateCsrWithHttpInfo(string id, CsrGenerate csrGenerate = default);

    /// <summary>
    /// get information for the selected key in selected token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views key details.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <returns>Key</returns>
    Key GetKey(string id);

    /// <summary>
    /// get information for the selected key in selected token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views key details.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <returns>ApiResponse of Key</returns>
    ApiResponse<Key> GetKeyWithHttpInfo(string id);

    /// <summary>
    /// get possible actions for one csr
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;UI needs to know which actions can be done on one csr.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <returns>List&lt;PossibleAction&gt;</returns>
    List<PossibleAction> GetPossibleActionsForCsr(string id, string csrId);

    /// <summary>
    /// get possible actions for one csr
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;UI needs to know which actions can be done on one csr.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <returns>ApiResponse of List&lt;PossibleAction&gt;</returns>
    ApiResponse<List<PossibleAction>> GetPossibleActionsForCsrWithHttpInfo(string id, string csrId);

    /// <summary>
    /// get possible actions for one key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;UI needs to know which actions can be done on one key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <returns>List&lt;PossibleAction&gt;</returns>
    List<PossibleAction> GetPossibleActionsForKey(string id);

    /// <summary>
    /// get possible actions for one key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;UI needs to know which actions can be done on one key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <returns>ApiResponse of List&lt;PossibleAction&gt;</returns>
    ApiResponse<List<PossibleAction>> GetPossibleActionsForKeyWithHttpInfo(string id);

    /// <summary>
    /// update key information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the key information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="keyName"> (optional)</param>
    /// <returns>Key</returns>
    Key UpdateKey(string id, KeyName keyName = default);

    /// <summary>
    /// update key information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the key information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="keyName"> (optional)</param>
    /// <returns>ApiResponse of Key</returns>
    ApiResponse<Key> UpdateKeyWithHttpInfo(string id, KeyName keyName = default);

    #endregion Synchronous Operations
}

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface IKeysApiAsync : IApiAccessor
{
    #region Asynchronous Operations

    /// <summary>
    /// delete csr from the selected key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator deletes csr from the key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    Task DeleteCsrAsync(string id, string csrId, CancellationToken cancellationToken = default);

    /// <summary>
    /// delete csr from the selected key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator deletes csr from the key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    Task<ApiResponse<object>> DeleteCsrWithHttpInfoAsync(string id, string csrId,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// delete key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator deletes the key.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response if sending an auth cert deletion management request fails. The metadata array contains the error details that were generated in core. The message is in plain English.&lt;/p&gt; &lt;p&gt; Note that with this endpoint it&#39;s possible to delete an authentication key with a registered authentication certificate. &lt;ul&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true succeeds. The authentication certificate is first unregistered, and the key and certificate are deleted after that.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;When trying to delete an authentication key with a registered authentication certificate, the warning response has a warning code &lt;code&gt;auth_key_with_registered_cert_warning&lt;/code&gt; and the metadata field contains the key id of the key&lt;/p&gt; &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="ignoreWarnings">if true, any ignorable warnings are ignored. if false (or missing), any warnings cause request to fail (optional, default to false)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    Task DeleteKeyAsync(string id, bool? ignoreWarnings = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// delete key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator deletes the key.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response if sending an auth cert deletion management request fails. The metadata array contains the error details that were generated in core. The message is in plain English.&lt;/p&gt; &lt;p&gt; Note that with this endpoint it&#39;s possible to delete an authentication key with a registered authentication certificate. &lt;ul&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true succeeds. The authentication certificate is first unregistered, and the key and certificate are deleted after that.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;When trying to delete an authentication key with a registered authentication certificate, the warning response has a warning code &lt;code&gt;auth_key_with_registered_cert_warning&lt;/code&gt; and the metadata field contains the key id of the key&lt;/p&gt; &lt;/p&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="ignoreWarnings">if true, any ignorable warnings are ignored. if false (or missing), any warnings cause request to fail (optional, default to false)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    Task<ApiResponse<object>> DeleteKeyWithHttpInfoAsync(string id, bool? ignoreWarnings = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// download a CSR binary
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads a csr that has been created earlier.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="csrFormat">format of the certificate signing request (PEM or DER) (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    Task<Stream> DownloadCsrAsync(string id, string csrId, CsrFormat? csrFormat = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// download a CSR binary
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator downloads a csr that has been created earlier.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="csrFormat">format of the certificate signing request (PEM or DER) (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    Task<ApiResponse<Stream>> DownloadCsrWithHttpInfoAsync(string id, string csrId, CsrFormat? csrFormat = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// generate csr for the selected key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates csr for the key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrGenerate">request to generate csr (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    Task<Stream> GenerateCsrAsync(string id, CsrGenerate csrGenerate = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// generate csr for the selected key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator generates csr for the key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrGenerate">request to generate csr (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    Task<ApiResponse<Stream>> GenerateCsrWithHttpInfoAsync(string id, CsrGenerate csrGenerate = default,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// get information for the selected key in selected token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views key details.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Key</returns>
    Task<Key> GetKeyAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// get information for the selected key in selected token
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator views key details.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Key)</returns>
    Task<ApiResponse<Key>> GetKeyWithHttpInfoAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// get possible actions for one csr
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;UI needs to know which actions can be done on one csr.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;PossibleAction&gt;</returns>
    Task<List<PossibleAction>> GetPossibleActionsForCsrAsync(string id, string csrId,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// get possible actions for one csr
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;UI needs to know which actions can be done on one csr.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;PossibleAction&gt;)</returns>
    Task<ApiResponse<List<PossibleAction>>> GetPossibleActionsForCsrWithHttpInfoAsync(string id, string csrId,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// get possible actions for one key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;UI needs to know which actions can be done on one key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;PossibleAction&gt;</returns>
    Task<List<PossibleAction>> GetPossibleActionsForKeyAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// get possible actions for one key
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;UI needs to know which actions can be done on one key.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;PossibleAction&gt;)</returns>
    Task<ApiResponse<List<PossibleAction>>> GetPossibleActionsForKeyWithHttpInfoAsync(string id,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// update key information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the key information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="keyName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Key</returns>
    Task<Key> UpdateKeyAsync(string id, KeyName keyName = default, CancellationToken cancellationToken = default);

    /// <summary>
    /// update key information
    /// </summary>
    /// <remarks>
    /// &lt;h3&gt;Administrator updates the key information.&lt;/h3&gt;
    /// </remarks>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="keyName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Key)</returns>
    Task<ApiResponse<Key>> UpdateKeyWithHttpInfoAsync(string id, KeyName keyName = default,
        CancellationToken cancellationToken = default);

    #endregion Asynchronous Operations
}

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public interface IKeysApi : IKeysApiSync, IKeysApiAsync
{
}

/// <summary>
/// Represents a collection of functions to interact with the API endpoints
/// </summary>
public class KeysApi : IKeysApi
{
    private ExceptionFactory _exceptionFactory = (_, _) => null;

    /// <summary>
    /// Initializes a new instance of the <see cref="KeysApi"/> class.
    /// </summary>
    /// <returns></returns>
    public KeysApi() : this(string.Empty)
    {
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="KeysApi"/> class.
    /// </summary>
    /// <returns></returns>
    public KeysApi(string basePath)
    {
        Configuration = Sdk.Client.Configuration.MergeConfigurations(
            GlobalConfiguration.Instance,
            new Configuration {BasePath = basePath}
        );
        Client = new ApiClient(Configuration.BasePath);
        AsynchronousClient = new ApiClient(Configuration.BasePath);
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="KeysApi"/> class
    /// using Configuration object
    /// </summary>
    /// <param name="configuration">An instance of Configuration</param>
    /// <returns></returns>
    public KeysApi(Configuration configuration)
    {
        if (configuration == null) throw new ArgumentNullException(nameof(configuration), "configuration");

        Configuration = Sdk.Client.Configuration.MergeConfigurations(
            GlobalConfiguration.Instance,
            configuration
        );
        Client = new ApiClient(Configuration.BasePath);
        AsynchronousClient = new ApiClient(Configuration.BasePath);
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="KeysApi"/> class
    /// using a Configuration object and client instance.
    /// </summary>
    /// <param name="client">The client interface for synchronous API access.</param>
    /// <param name="asyncClient">The client interface for asynchronous API access.</param>
    /// <param name="configuration">The configuration object.</param>
    public KeysApi(ISynchronousClient client, IAsynchronousClient asyncClient, IReadableConfiguration configuration)
    {
        Client = client ?? throw new ArgumentNullException(nameof(client), "client");
        AsynchronousClient = asyncClient ?? throw new ArgumentNullException(nameof(asyncClient), "asyncClient");
        Configuration = configuration ?? throw new ArgumentNullException(nameof(configuration), "configuration");
        ExceptionFactory = Sdk.Client.Configuration.DefaultExceptionFactory;
    }

    /// <summary>
    /// The client for accessing this underlying API asynchronously.
    /// </summary>
    public IAsynchronousClient AsynchronousClient { get; set; }

    /// <summary>
    /// The client for accessing this underlying API synchronously.
    /// </summary>
    public ISynchronousClient Client { get; set; }

    /// <summary>
    /// Gets the base path of the API client.
    /// </summary>
    /// <value>The base path</value>
    public string GetBasePath()
    {
        return Configuration.BasePath;
    }

    /// <summary>
    /// Gets or sets the configuration object
    /// </summary>
    /// <value>An instance of the Configuration</value>
    public IReadableConfiguration Configuration { get; set; }

    /// <summary>
    /// Provides a factory method hook for the creation of exceptions.
    /// </summary>
    public ExceptionFactory ExceptionFactory
    {
        get
        {
            if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
            return _exceptionFactory;
        }
        set => _exceptionFactory = value;
    }

    /// <summary>
    /// delete csr from the selected key &lt;h3&gt;Administrator deletes csr from the key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <returns></returns>
    public void DeleteCsr(string id, string csrId)
    {
        DeleteCsrWithHttpInfo(id, csrId);
    }

    /// <summary>
    /// delete csr from the selected key &lt;h3&gt;Administrator deletes csr from the key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <returns>ApiResponse of Object(void)</returns>
    public ApiResponse<object> DeleteCsrWithHttpInfo(string id, string csrId)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->DeleteCsr");

        // verify the required parameter 'csrId' is set
        if (csrId == null)
            throw new ApiException(400, "Missing required parameter 'csrId' when calling KeysApi->DeleteCsr");

        var localVarRequestOptions = new RequestOptions();


        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(Array.Empty<string>());
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.PathParameters.Add("csr_id", ClientUtils.ParameterToString(csrId)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Delete<object>("/keys/{id}/csrs/{csr_id}", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("DeleteCsr", localVarResponse) is { } exception) throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// delete csr from the selected key &lt;h3&gt;Administrator deletes csr from the key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    public async Task DeleteCsrAsync(string id, string csrId, CancellationToken cancellationToken = default)
    {
        await DeleteCsrWithHttpInfoAsync(id, csrId, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// delete csr from the selected key &lt;h3&gt;Administrator deletes csr from the key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    public async Task<ApiResponse<object>> DeleteCsrWithHttpInfoAsync(string id, string csrId,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->DeleteCsr");

        // verify the required parameter 'csrId' is set
        if (csrId == null)
            throw new ApiException(400, "Missing required parameter 'csrId' when calling KeysApi->DeleteCsr");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(Array.Empty<string>());
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.PathParameters.Add("csr_id", ClientUtils.ParameterToString(csrId)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .DeleteAsync<object>("/keys/{id}/csrs/{csr_id}", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        var exception = ExceptionFactory?.Invoke("DeleteCsr", localVarResponse);
        if (exception != null)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// delete key &lt;h3&gt;Administrator deletes the key.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response if sending an auth cert deletion management request fails. The metadata array contains the error details that were generated in core. The message is in plain English.&lt;/p&gt; &lt;p&gt; Note that with this endpoint it&#39;s possible to delete an authentication key with a registered authentication certificate. &lt;ul&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true succeeds. The authentication certificate is first unregistered, and the key and certificate are deleted after that.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;When trying to delete an authentication key with a registered authentication certificate, the warning response has a warning code &lt;code&gt;auth_key_with_registered_cert_warning&lt;/code&gt; and the metadata field contains the key id of the key&lt;/p&gt; &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="ignoreWarnings">if true, any ignorable warnings are ignored. if false (or missing), any warnings cause request to fail (optional, default to false)</param>
    /// <returns></returns>
    public void DeleteKey(string id, bool? ignoreWarnings = default)
    {
        DeleteKeyWithHttpInfo(id, ignoreWarnings);
    }

    /// <summary>
    /// delete key &lt;h3&gt;Administrator deletes the key.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response if sending an auth cert deletion management request fails. The metadata array contains the error details that were generated in core. The message is in plain English.&lt;/p&gt; &lt;p&gt; Note that with this endpoint it&#39;s possible to delete an authentication key with a registered authentication certificate. &lt;ul&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true succeeds. The authentication certificate is first unregistered, and the key and certificate are deleted after that.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;When trying to delete an authentication key with a registered authentication certificate, the warning response has a warning code &lt;code&gt;auth_key_with_registered_cert_warning&lt;/code&gt; and the metadata field contains the key id of the key&lt;/p&gt; &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="ignoreWarnings">if true, any ignorable warnings are ignored. if false (or missing), any warnings cause request to fail (optional, default to false)</param>
    /// <returns>ApiResponse of Object(void)</returns>
    public ApiResponse<object> DeleteKeyWithHttpInfo(string id, bool? ignoreWarnings = default)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->DeleteKey");

        var localVarRequestOptions = new RequestOptions();


        // to determine the Accept header
        string[] accepts =
        {
            "application/json"
        };

        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(accepts);
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        if (ignoreWarnings != null)
            localVarRequestOptions.QueryParameters.Add(
                ClientUtils.ParameterToMultiMap("", "ignore_warnings", ignoreWarnings));

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Delete<object>("/keys/{id}", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("DeleteKey", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// delete key &lt;h3&gt;Administrator deletes the key.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response if sending an auth cert deletion management request fails. The metadata array contains the error details that were generated in core. The message is in plain English.&lt;/p&gt; &lt;p&gt; Note that with this endpoint it&#39;s possible to delete an authentication key with a registered authentication certificate. &lt;ul&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true succeeds. The authentication certificate is first unregistered, and the key and certificate are deleted after that.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;When trying to delete an authentication key with a registered authentication certificate, the warning response has a warning code &lt;code&gt;auth_key_with_registered_cert_warning&lt;/code&gt; and the metadata field contains the key id of the key&lt;/p&gt; &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="ignoreWarnings">if true, any ignorable warnings are ignored. if false (or missing), any warnings cause request to fail (optional, default to false)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of void</returns>
    public async Task DeleteKeyAsync(string id, bool? ignoreWarnings = default,
        CancellationToken cancellationToken = default)
    {
        await DeleteKeyWithHttpInfoAsync(id, ignoreWarnings, cancellationToken).ConfigureAwait(false);
    }

    /// <summary>
    /// delete key &lt;h3&gt;Administrator deletes the key.&lt;/h3&gt; &lt;p&gt;This endpoint can also return metadata in the error response if sending an auth cert deletion management request fails. The metadata array contains the error details that were generated in core. The message is in plain English.&lt;/p&gt; &lt;p&gt; Note that with this endpoint it&#39;s possible to delete an authentication key with a registered authentication certificate. &lt;ul&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; false causes the operation to fail with a warning in response&#39;s ErrorInfo object.&lt;/li&gt; &lt;li&gt;Attempt to delete an authentication key with a registered authentication certificate and with &lt;code&gt;ignore_warnings&lt;/code&gt; &#x3D; true succeeds. The authentication certificate is first unregistered, and the key and certificate are deleted after that.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;When trying to delete an authentication key with a registered authentication certificate, the warning response has a warning code &lt;code&gt;auth_key_with_registered_cert_warning&lt;/code&gt; and the metadata field contains the key id of the key&lt;/p&gt; &lt;/p&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="ignoreWarnings">if true, any ignorable warnings are ignored. if false (or missing), any warnings cause request to fail (optional, default to false)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse</returns>
    public async Task<ApiResponse<object>> DeleteKeyWithHttpInfoAsync(string id, bool? ignoreWarnings = default,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->DeleteKey");


        var localVarRequestOptions = new RequestOptions();


        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[]
        {
            "application/json"
        });
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        if (ignoreWarnings != null)
            localVarRequestOptions.QueryParameters.Add(
                ClientUtils.ParameterToMultiMap("", "ignore_warnings", ignoreWarnings));

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .DeleteAsync<object>("/keys/{id}", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("DeleteKey", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// download a CSR binary &lt;h3&gt;Administrator downloads a csr that has been created earlier.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="csrFormat">format of the certificate signing request (PEM or DER) (optional)</param>
    /// <returns>System.IO.Stream</returns>
    public Stream DownloadCsr(string id, string csrId, CsrFormat? csrFormat = default)
    {
        var localVarResponse = DownloadCsrWithHttpInfo(id, csrId, csrFormat);
        return localVarResponse.Data;
    }

    /// <summary>
    /// download a CSR binary &lt;h3&gt;Administrator downloads a csr that has been created earlier.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="csrFormat">format of the certificate signing request (PEM or DER) (optional)</param>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    public ApiResponse<Stream> DownloadCsrWithHttpInfo(string id, string csrId, CsrFormat? csrFormat = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->DownloadCsr");

        // verify the required parameter 'csrId' is set
        if (csrId == null)
            throw new ApiException(400, "Missing required parameter 'csrId' when calling KeysApi->DownloadCsr");

        var localVarRequestOptions = new RequestOptions();


        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[]
        {
            "application/octet-stream"
        });
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.PathParameters.Add("csr_id", ClientUtils.ParameterToString(csrId)); // path parameter
        if (csrFormat != null)
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "csr_format", csrFormat));

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Get<Stream>("/keys/{id}/csrs/{csr_id}", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("DownloadCsr", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// download a CSR binary &lt;h3&gt;Administrator downloads a csr that has been created earlier.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="csrFormat">format of the certificate signing request (PEM or DER) (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    public async Task<Stream> DownloadCsrAsync(string id, string csrId, CsrFormat? csrFormat = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse = await DownloadCsrWithHttpInfoAsync(id, csrId, csrFormat, cancellationToken)
            .ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// download a CSR binary &lt;h3&gt;Administrator downloads a csr that has been created earlier.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="csrFormat">format of the certificate signing request (PEM or DER) (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    public async Task<ApiResponse<Stream>> DownloadCsrWithHttpInfoAsync(string id, string csrId,
        CsrFormat? csrFormat = default, CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->DownloadCsr");

        // verify the required parameter 'csrId' is set
        if (csrId == null)
            throw new ApiException(400, "Missing required parameter 'csrId' when calling KeysApi->DownloadCsr");


        var localVarRequestOptions = new RequestOptions();


        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[]
        {
            "application/octet-stream"
        });
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.PathParameters.Add("csr_id", ClientUtils.ParameterToString(csrId)); // path parameter
        if (csrFormat != null)
            localVarRequestOptions.QueryParameters.Add(ClientUtils.ParameterToMultiMap("", "csr_format", csrFormat));

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<Stream>("/keys/{id}/csrs/{csr_id}", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("DownloadCsr", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// generate csr for the selected key &lt;h3&gt;Administrator generates csr for the key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrGenerate">request to generate csr (optional)</param>
    /// <returns>System.IO.Stream</returns>
    public Stream GenerateCsr(string id, CsrGenerate csrGenerate = default)
    {
        var localVarResponse = GenerateCsrWithHttpInfo(id, csrGenerate);
        return localVarResponse.Data;
    }

    /// <summary>
    /// generate csr for the selected key &lt;h3&gt;Administrator generates csr for the key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrGenerate">request to generate csr (optional)</param>
    /// <returns>ApiResponse of System.IO.Stream</returns>
    public ApiResponse<Stream> GenerateCsrWithHttpInfo(string id, CsrGenerate csrGenerate = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->GenerateCsr");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new[] {"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/octet-stream"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = csrGenerate;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Post<Stream>("/keys/{id}/csrs", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GenerateCsr", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// generate csr for the selected key &lt;h3&gt;Administrator generates csr for the key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrGenerate">request to generate csr (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of System.IO.Stream</returns>
    public async Task<Stream> GenerateCsrAsync(string id, CsrGenerate csrGenerate = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse =
            await GenerateCsrWithHttpInfoAsync(id, csrGenerate, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// generate csr for the selected key &lt;h3&gt;Administrator generates csr for the key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrGenerate">request to generate csr (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (System.IO.Stream)</returns>
    public async Task<ApiResponse<Stream>> GenerateCsrWithHttpInfoAsync(string id, CsrGenerate csrGenerate = default,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->GenerateCsr");


        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(new[] {"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/octet-stream"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = csrGenerate;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PostAsync<Stream>("/keys/{id}/csrs", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("GenerateCsr", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get information for the selected key in selected token &lt;h3&gt;Administrator views key details.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <returns>Key</returns>
    public Key GetKey(string id)
    {
        var localVarResponse = GetKeyWithHttpInfo(id);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get information for the selected key in selected token &lt;h3&gt;Administrator views key details.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <returns>ApiResponse of Key</returns>
    public ApiResponse<Key> GetKeyWithHttpInfo(string id)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->GetKey");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Get<Key>("/keys/{id}", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GetKey", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get information for the selected key in selected token &lt;h3&gt;Administrator views key details.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Key</returns>
    public async Task<Key> GetKeyAsync(string id, CancellationToken cancellationToken = default)
    {
        var localVarResponse = await GetKeyWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get information for the selected key in selected token &lt;h3&gt;Administrator views key details.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Key)</returns>
    public async Task<ApiResponse<Key>> GetKeyWithHttpInfoAsync(string id,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->GetKey");
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<Key>("/keys/{id}", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("GetKey", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get possible actions for one csr &lt;h3&gt;UI needs to know which actions can be done on one csr.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <returns>List&lt;PossibleAction&gt;</returns>
    public List<PossibleAction> GetPossibleActionsForCsr(string id, string csrId)
    {
        var localVarResponse = GetPossibleActionsForCsrWithHttpInfo(id, csrId);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get possible actions for one csr &lt;h3&gt;UI needs to know which actions can be done on one csr.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <returns>ApiResponse of List&lt;PossibleAction&gt;</returns>
    public ApiResponse<List<PossibleAction>> GetPossibleActionsForCsrWithHttpInfo(string id, string csrId)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400,
                "Missing required parameter 'id' when calling KeysApi->GetPossibleActionsForCsr");

        // verify the required parameter 'csrId' is set
        if (csrId == null)
            throw new ApiException(400,
                "Missing required parameter 'csrId' when calling KeysApi->GetPossibleActionsForCsr");
        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.PathParameters.Add("csr_id", ClientUtils.ParameterToString(csrId)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Get<List<PossibleAction>>("/keys/{id}/csrs/{csr_id}/possible-actions",
            localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GetPossibleActionsForCsr", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get possible actions for one csr &lt;h3&gt;UI needs to know which actions can be done on one csr.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;PossibleAction&gt;</returns>
    public async Task<List<PossibleAction>> GetPossibleActionsForCsrAsync(string id, string csrId,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse = await GetPossibleActionsForCsrWithHttpInfoAsync(id, csrId, cancellationToken)
            .ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get possible actions for one csr &lt;h3&gt;UI needs to know which actions can be done on one csr.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="csrId">id of the csr</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;PossibleAction&gt;)</returns>
    public async Task<ApiResponse<List<PossibleAction>>> GetPossibleActionsForCsrWithHttpInfoAsync(string id,
        string csrId, CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400,
                "Missing required parameter 'id' when calling KeysApi->GetPossibleActionsForCsr");

        // verify the required parameter 'csrId' is set
        if (csrId == null)
            throw new ApiException(400,
                "Missing required parameter 'csrId' when calling KeysApi->GetPossibleActionsForCsr");


        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.PathParameters.Add("csr_id", ClientUtils.ParameterToString(csrId)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .GetAsync<List<PossibleAction>>("/keys/{id}/csrs/{csr_id}/possible-actions", localVarRequestOptions,
                Configuration, cancellationToken).ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("GetPossibleActionsForCsr", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get possible actions for one key &lt;h3&gt;UI needs to know which actions can be done on one key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <returns>List&lt;PossibleAction&gt;</returns>
    public List<PossibleAction> GetPossibleActionsForKey(string id)
    {
        var localVarResponse = GetPossibleActionsForKeyWithHttpInfo(id);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get possible actions for one key &lt;h3&gt;UI needs to know which actions can be done on one key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <returns>ApiResponse of List&lt;PossibleAction&gt;</returns>
    public ApiResponse<List<PossibleAction>> GetPossibleActionsForKeyWithHttpInfo(string id)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400,
                "Missing required parameter 'id' when calling KeysApi->GetPossibleActionsForKey");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse =
            Client.Get<List<PossibleAction>>("/keys/{id}/possible-actions", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("GetPossibleActionsForKey", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// get possible actions for one key &lt;h3&gt;UI needs to know which actions can be done on one key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of List&lt;PossibleAction&gt;</returns>
    public async Task<List<PossibleAction>> GetPossibleActionsForKeyAsync(string id,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse =
            await GetPossibleActionsForKeyWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// get possible actions for one key &lt;h3&gt;UI needs to know which actions can be done on one key.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (List&lt;PossibleAction&gt;)</returns>
    public async Task<ApiResponse<List<PossibleAction>>> GetPossibleActionsForKeyWithHttpInfoAsync(string id,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null)
            throw new ApiException(400,
                "Missing required parameter 'id' when calling KeysApi->GetPossibleActionsForKey");

        var localVarRequestOptions = new RequestOptions();
        var localVarContentType = ClientUtils.SelectHeaderContentType(Array.Empty<string>());
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient.GetAsync<List<PossibleAction>>("/keys/{id}/possible-actions",
            localVarRequestOptions, Configuration, cancellationToken).ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("GetPossibleActionsForKey", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// update key information &lt;h3&gt;Administrator updates the key information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="keyName"> (optional)</param>
    /// <returns>Key</returns>
    public Key UpdateKey(string id, KeyName keyName = default)
    {
        var localVarResponse = UpdateKeyWithHttpInfo(id, keyName);
        return localVarResponse.Data;
    }

    /// <summary>
    /// update key information &lt;h3&gt;Administrator updates the key information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="keyName"> (optional)</param>
    /// <returns>ApiResponse of Key</returns>
    public ApiResponse<Key> UpdateKeyWithHttpInfo(string id, KeyName keyName = default)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->UpdateKey");

        var localVarRequestOptions = new RequestOptions();

        var localVarContentType = ClientUtils.SelectHeaderContentType(new[] {"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = keyName;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = Client.Patch<Key>("/keys/{id}", localVarRequestOptions, Configuration);
        if (ExceptionFactory?.Invoke("UpdateKey", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }

    /// <summary>
    /// update key information &lt;h3&gt;Administrator updates the key information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="keyName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of Key</returns>
    public async Task<Key> UpdateKeyAsync(string id, KeyName keyName = default,
        CancellationToken cancellationToken = default)
    {
        var localVarResponse = await UpdateKeyWithHttpInfoAsync(id, keyName, cancellationToken).ConfigureAwait(false);
        return localVarResponse.Data;
    }

    /// <summary>
    /// update key information &lt;h3&gt;Administrator updates the key information.&lt;/h3&gt;
    /// </summary>
    /// <exception cref="ApiException">Thrown when fails to make API call</exception>
    /// <param name="id">id of the key</param>
    /// <param name="keyName"> (optional)</param>
    /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
    /// <returns>Task of ApiResponse (Key)</returns>
    public async Task<ApiResponse<Key>> UpdateKeyWithHttpInfoAsync(string id, KeyName keyName = default,
        CancellationToken cancellationToken = default)
    {
        // verify the required parameter 'id' is set
        if (id == null) throw new ApiException(400, "Missing required parameter 'id' when calling KeysApi->UpdateKey");
        var localVarRequestOptions = new RequestOptions();

        var localVarContentType = ClientUtils.SelectHeaderContentType(new[] {"application/json"});
        if (localVarContentType != null)
            localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

        var localVarAccept = ClientUtils.SelectHeaderAccept(new[] {"application/json"});
        if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

        localVarRequestOptions.PathParameters.Add("id", ClientUtils.ParameterToString(id)); // path parameter
        localVarRequestOptions.Data = keyName;

        // authentication (ApiKeyAuth) required
        if (!string.IsNullOrEmpty(Configuration.GetApiKeyWithPrefix("Authorization")))
            localVarRequestOptions.HeaderParameters.Add("Authorization",
                Configuration.GetApiKeyWithPrefix("Authorization"));

        // make the HTTP request
        var localVarResponse = await AsynchronousClient
            .PatchAsync<Key>("/keys/{id}", localVarRequestOptions, Configuration, cancellationToken)
            .ConfigureAwait(false);

        if (ExceptionFactory?.Invoke("UpdateKey", localVarResponse) is { } exception)
            throw exception;

        return localVarResponse;
    }
}